# IBM ile Kodluyoruz Notlarım

![IBM İLE KODLUYORUZ](https://github.com/burakarslan0110/IBM-Kodluyoruz-CyberStart/assets/140614856/7ddd503b-2485-4a2b-969c-77b13664d163)

CyberStart kapsamında Python programlama dili, Siber Güvenlik, Yapay Zeka (AI), Blok Zincir (Blockchain), Bulut Bilişim (Cloud Computing), Nesnelerin İnterneti (IoT), Bilgisayar Ağları ve Teknik Olmayan Yetkinlikler (Soft Skills) gibi birçok konuyu 6 haftalık süreçte ele aldım ve ürettiğim ders materyallerini GitHub repomda topladım.

Notlarımda yer alan görsellerin kaynağı IBM SkillsBuild platformudur.

---

## 1. Hafta

- **GENEL KÜLTÜR**
    - "*Algoritma*" kelimesinin kökeni 9. yüzyılda yaşamış İranlı matematikçi, gökbilimci ve coğrafyacı Ebu Cafer Muhammed İbn-i Musa el Harezmi'nin isminden gelmektedir. "*Kitab el cebr ve’l mukabele*" (cebir) başlığıyla çok etkili olmuş bir matematik ders kitabı yazmıştır.
    
    - İlk bilgisayarlar, insanların hesaplamalarını yapmalarına yardımcı olmak için tasarlandı.
    
    - 19 . yüzyılın sonu 20. yüzyılın başında Charles Babbage, dişliler, kollar ve kıvılcım alıcıları kullanarak hesaplamalar yapabilen Analitik Makine'yi tasarladı. Bu, bilgisayar programlamasında önemli bir gelişmeydi.
    
    - Lovelace Kontesi unvanıyla da anılan Augusta Ada King, diğer bir yaygın ismiyle Ada Lovelace, İngiliz matematikçi ve yazardır. Charles Babbage'in Analitik Makine’siyle alakalı aldığı notlar, ilk bilgisayar algoritmasını içerdiği için kendisi dünyanın ilk bilgisayar programcısı olarak kabul edilir. Ek olarak NVIDIA’nın RTX 4000 serisi ekran kartlarının Ada mimarisinin ismi de bu bağlamdan gelir.
    
    - Bilgisayar programlamasındaki diğer bir önemli atılım, 1950'lerde FORTRAN, COBOL ve BASIC gibi ilk programlama dillerinin geliştirilmesiyle etkisini gösterdi. Bu diller, bilgisayarların karmaşık işlemler yapabilmesini olanak tanıdı.
    
    - 1970'lerde ise C ve Pascal gibi yüksek seviye diller geliştirildi. Bu diller, programcılara geliştirdikleri yazılımlar üzerinde daha fazla kontrol ve esneklik sağladı.
    
    - Apple ve Microsoft'un kişisel bilgisayarları popüler hale getirmesiyle birlikte başlayan 1980 ve 1990 döneminde programlama daha da yaygın ve anlaşılır hale geldi. Bu zaman aralığında çıkan C++ ve Java gibi nesne yönelimi etrafında şekillenen diller günümüzde dahi önemi korumaktadır.
    
    - 2000’lerin başında, web uygulamalarının yükseliş göstermesiyle beraber tahmin edileceği üzere JavaScript ve PHP gibi diller çok popüler oldu.
    
    - 2010’a doğru iOS ve Android gibi mobil işletim sistemlerinin hayatımıza girmesiyle birlikte Swift ve Kotlin dillerine de tanıklık ettik.
    
    - Günümüzde ise en popüler programlama dilleri arasında Java, Python, C++, C#, JavaScript, PHP ve Ruby yer alıyor.

- **TEMEL BİLGİSAYAR BİLİMİ KAVRAMLARI**
    - Bilgisayar: Aritmetiksel ve mantıksal işlemlerden oluşan bir işi, önceden verilmiş programa göre yapıp sonuçlandıran elektronik bir araçtır. İşlemci, bellek, giriş/çıkış aygıtlarından oluşur.
    
    - Bilgisayar bilimi: Bilgisayarların ve hesaplamaların teorisi, tasarımı, geliştirilmesi ve uygulanmasıyla ilgilenen; Yazılım, donanım ve tasarım üçlüsü etrafında şekillenen bilim dalı.
    
    - Donanım: Bilgisayarda gözle görebildiğimiz fiziksel parçalar donanım olarak isimlendirilir. İşlemci, bellek, depolama aygıtları ve giriş/çıkış aygıtları donanım örnekleri arasındadır.
    
    - Yazılım: Bilgisayarın çalışması için donanım dışında kalan kısma yazılım denir. Yani,
    yapılması gereken işler için donanıma komutlar veren programlar topluluğudur.
    
    - İşletim sistemi: Bir bilgisayarın donanımını yöneten ve bilgisayar kullanıcıları ile uygulamalar arasında iletişim kuran ana sistem. Temel görevi, bilgisayarın kaynaklarını (donanımı) etkili bir şekilde yönetmek ve kullanıcıya ve uygulamalara hizmet etmektir.
    
    - Programlama dili: Bilgisayarların anlayabileceği komutları yazmak için kullanılan yapılardan oluşan talimatlar kümesi. İnsanların anlayabileceği düz metin formatında yazılan komutlar, daha sonra derleyici veya yorumlayıcı gibi araçlarla bilgisayar tarafından anlaşılabilir hale getirilir ve çalıştırılır.
    
    - Algoritma: En basit ifadeyle, bir problemi çözmek için takip edilecek sonlu sayıda adımdan oluşan bir çözüm yoludur.
    
    - Veri: İşlenmiş veya işlenmemiş bilgisayar ortamında tutulabilen bilgi parçalarıdır. Bilgisayar biliminde ve bilgi teknolojilerinde, veri genellikle sayılar, metinler, görüntüler, sesler veya herhangi bir dijital format içinde temsil edilen her türlü bilgiyi ifade eder.
    
    - Veri tabanı: Büyük miktarda veriyi düzenli bir şekilde saklamak, güncellemek, sorgulamak ve yönetmek için kullanılan yapılardır.
    
    - Ağ: Bilgisayarlar, cihazlar ve diğer iletişim aygıtları arasında bilgi ve veri paylaşımını sağlayan yapıdır. Temelde bir ağ, bağlı cihazların iletişim kurabilmesi için birbirine bağlanmış bir dizi donanım ve yazılım bileşeninden oluşur.

- **IBM PROFESSIONAL SKILLS 1 (AMAÇ ODAKLI SUNUM YAPMA)**
    - **KONU 1: HEDEFLERE ODAKLANMA**
        - Hedefler sunumunuza bir amaç kazandırır.
        - Üzerinde yeniden çalışmaya gerek kalmaması için sunumunuzu oluşturmadan önce hedeflerinize odaklanın
        - Hedefleri belirlerken, sunumunuzu neden oluşturduğunuza ilişkin nedenleri de belirleyip düşünün.
        - Bir sunumun hedefi üç kategoriye ayrılır: bilgi edinme, harekete geçme ve hissetme.
          
          ![IBM PROFESSIONAL SKILLS 1 GÖRSEL](https://github.com/burakarslan0110/IBM-Kodluyoruz-CyberStart/assets/140614856/4f779b70-de31-4f57-b82b-c5f1e3ed7ec0)
        - Sunumunuzun mesajını hedefe ulaşacak şekilde iyileştirmek ve geliştirmek için üç basit hedef kategorisi kullanın. Hedef kitleniz için sonucun ne olmasını istiyorsunuz: Bilgi edinmek mi? Harekete geçmek mi?
    
    - **KONU 2: HEDEF KİTLEYİ TANIMA**
        - Başarılı bir sunum, izleyicilerle etkileşime dayalı bir iletişimdir. İzleyiciler, sunumunuzun merkezindedir; onlar hedef kitleniz ve mesajınızın doğrudan alıcısıdır. Sunumunuzun etkisi, onların tepkisi ve geri bildirimiyle şekillenir.
        - Hedef kitlenizin özellikleri hakkında bilmeniz gerekenler: İhtiyaçları, Sayıları, İlgi Alanları, Zorlukları, Tutumları, Görevleri, Konuyla ilgili geçmiş deneyimleri
        - Hedef kitlenizi tanımak sunumu ne açılardan nasıl etkiler: Ton, Uzunluk, Tarz, İçerik
        - Sunum esnasındaki iki algı türü vardır: Hedef kitlenizin sizi nasıl algıladığı ve sizin nasıl algılanmak istediğiniz

          ![IBM PROFESSIONAL SKILLS 1 GÖRSEL 2](https://github.com/burakarslan0110/IBM-Kodluyoruz-CyberStart/assets/140614856/e7dc6e36-def9-426d-aefe-3c51652ceb83)
    
    - **KONU 3: SUNUM YAPISINI OLUŞTURMA**
        - Sunumunuzu bir açılış, gelişme ve kapanışı içerecek şekilde yapılandırın.
     
          ![IBM PROFESSIONAL SKILLS 1 GÖRSEL 3](https://github.com/burakarslan0110/IBM-Kodluyoruz-CyberStart/assets/140614856/c9b89cf1-0899-4131-82f6-e9f53894ec90)

        - Hedeflerin ve hedef kitlenin sunumunuzun yapısı üzerindeki etkisini düşünün.
        - Sunumunuza dahil edilecek bilgi miktarı, yalnızca hedefinize ulaşmak için gerekenleri içermelidir.
        - Bazı kişilerin daha fazla ayrıntıyla ilgilenebileceğini düşünüyorsanız, onlara daha sonra ek bilgi sağlamayı unutmayın.
    
    - **KONU 4: SUNUM SLAYTLARINI TASARLAMA**
        - Başlık olarak manşetler veya tam cümleler kullanın.
        - Uygun resimler kullanın.
        - Çok fazla metinden kaçının.
        - Okunabilir bir yazı tipi boyutu kullanın.
        - Karmaşık grafikleri birkaç slayda bölün.
        - Önemli noktalarınızı listeleyen bir belge paylaşın.
    
    - **KONU 5: DAHA ETKİLİ BİR ŞEKİLDE SUNUM YAPMA**
        - Anımsatmaya yönelik bir dil kullanma
        - hikayeler anlatma
        - Fiziksel sahne donanımı veya ayırt edici görsel resimler kullanma
        - Hedef kitlenizi tartışmaya dahil etme
        - Kontrollü, ancak canlı bir şekilde konuşma ve hareket etme
    
    - **KONU 6: GERGİNLİĞİ YÖNETME**
        - Sunumlardan önce gergin hissetmek doğaldır.
     
          ![IBM PROFESSIONAL SKILLS 1 GÖRSEL 4](https://github.com/burakarslan0110/IBM-Kodluyoruz-CyberStart/assets/140614856/c3243bf8-d919-4185-ba86-964f0a08acbf)

        - Gerginliğin verdiği enerjiyi kendi yararımıza kullanabiliriz.
            - Kendinize değil, hedef kitleye odaklanın.
            - Korkuyu adrenalin olarak yeniden tanımlayın.
            - İletmek istediğiniz duyguya odaklanın.
    
    - **KONU 7: BEKLENMEYEN DURUMLARLA BAŞA ÇIKMA**
        - Hedef kitlenizin olası soruları için önceden plan yapma.
        - Soruları kısa ve net bir biçimde yanıtlama.
        - Soruyu yeniden ifade etme.
        - Size sorulan soruyu belirtin.
        - Prova yapmak ve genel kontrol, etkili bir sunum yapmada altın anahtardır.

- **PYHTON 1**
    - **PHYTON NEDİR?**
        
        Python, kullanımı kolay syntax yapısı, geniş kütüphane desteği ve çeşitli kullanım alanlarıyla öne çıkan yüksek seviyeli bir programlama dilidir. Hem yeni başlayanlar hem de deneyimli geliştiriciler için ideal olan Python, web geliştirme, veri analizi, yapay zeka, bilimsel hesaplama gibi birçok alanda yaygın olarak kullanılmaktadır.
        
    
    - **TEMEL VERİ TİPLERİ**
        - Programlara istediğimiz işlemleri yaptırabilmek için girdilerimizi ve program içerisindeki verileri ifade etmemiz gerekir. Bu ifadeyi veri objelerini kullanarak yaparız.
        - Programlar veri objelerini (data object) manipüle ederek istediğimiz işlemleri gerçekleştirirler.
        - Veri objeleri ikiye ayrılır: Scalar (Alt parçalara bölünemeyen yapılar) ve Non-scalar (Bulunduğu durumdan daha alt parçalara bölünebilen, içsel üyelerine eriştiğimiz yapılar)
        - Değişkenlere değer atamada C# ve Java gibi dillerden farklı olarak Pyhton’da değişken tipini belirtmemiz gerekmez.
            - Scalar veri objeleri
                - Integers (Tam sayılar)
                    
                    ```python
                    x = 10
                    y = -5
                    z = 0
                    ```
                    
                - Floats (Kesirli sayılar)
                    
                    ```python
                    x = 3.6
                    y = 4.3
                    z = 6.2
                    ```
                    
                - Boolean (Mantıksal değerler)
                    
                    ```python
                    yagmurlu = True
                    yagisli = False
                    ```
                    
                - Complex (Karmaşık sayılar)
                    
                    ```python
                    z1 = 3 + 4j
                    z2 = 1 - 2j
                    ```
                    
            - Non-scalar veri objeleri
                - String (karakter dizileri)
                    
                    ```python
                    name = "Burak"
                    surname = 'Arslan'
                    full_name = "Arslan"
                    ```
                    
                - List (Listeler)
                    
                    ```python
                    # List sıralı ve değiştirilebilir (mutable) veri öğelerinin bir koleksiyonudur.
                    sayilar = [1, 22, 3, 4, 65, 7, 86, 53]
                    meyveler = ["elma", "portakal", "kiraz"]
                    karisik_liste = [9, "elma", True]
                    ```
                    
                - Set (Kümeler)
                    
                    ```python
                    # Set benzersiz ve sırasız elemanlardan oluşan veri yapılarıdır.
                    rakamlar = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
                    harfler = {'a', 'e', 'i'}
                    ```
                    
                - Dictionary (Sözlükler)
                    
                    ```python
                    # Dictionary (sözlük), anahtar-değer (key-value) çiftlerini saklayan ve hızlı veri erişimi sağlayan değiştirilebilir (mutable) bir veri yapısıdır.
                    calisan = {"isim": "Burak", "soyisim": "Arslan", "yas": 26, "sehir": "Ankara"}
                    araba = {"marka": "Honda", "model": "Civic", "yil": 2020}
                    ```
                    
                - Tuple (Demetler)
                    
                    ```python
                    # Tuple, birden fazla değeri bir arada tutmak için kullanılan ve değiştirilemez (immutable) bir veri yapısıdır.
                    
                    my_tuple = (1, 2, 3)
                    mixed_tuple = (1, "hello", 3.14, True)
                    ```
                    
        - Tipler arasında dönüşüm yapmak için “*veri tipi adı(değişken)*” fonksiyon yapısı kullanılır.
        
        ```python
        #Bir string ifadeyi tamsayıya dönüştürmek
        number_str = "123"
        number_int = int(number_str)
        print(number_int)  # 123
        
        #Bir string ifadeyi ondalıklı sayıya dönüştürme
        number_str = "3.14"
        number_float = float(number_str)
        print(number_float)  # 3.14
        
        #Bir nesneyi veya değeri string'e dönüştürme
        number_str = str(number)
        print(number_str)  # "123"
        
        ```
        
    
    - **OPERATÖRLER**
        - **ARİTMETİK OPERATÖRLER**
            - **`+`:** İki değeri toplar.
            - **`-`:** İki değeri çıkarır.
            - **`*`:** İki değeri çarpar.
            - **`/`:** İlk değeri ikinci değere böler.
            - `//`: İlk değeri ikinci değere böler ve tam sayı kısmını döndürür.
            - `**`: İlk değerin ikinci değere göre üssünü alır.
            - **`%`:** İlk değerin ikinci değere bölümünün kalanını verir, yani modunu alır.
        
        - **KARŞILAŞTIRMA OPERATÖRLERİ**
            - `==` : Eşit mi?
            - `=!` : Eşit değil mi?
            - `>` : Büyük mü?
            - `<` : Küçük mi?
            - `>=` Büyük veya eşit mi?
            - `<=` Küçük veya eşit mi?
        
        - **MANTIKSAL OPERATÖRLER**
            - `and`: ve
            - `or`: veya
            - `not`: değil
        
        - **ÜYELİK OPERATÖRLERİ**
            - `in`: Bir elemanın bir veri yapısında bulunup bulunmadığını kontrol eder.
            - `not in`: Bir elemanın bir veri yapısında bulunmadığını kontrol eder.
        
        - **KİMLİK OPERATÖRLERİ**
            - `is`:  İki nesne aynı mı?
            - `is not`: İki nesne aynı değil mi?
        
        - **ATAMA OPERATÖRLERİ**
            - `=`: Eşitliğin sağındaki değeri sola atama.
            - `+=`, `-=`, `*=`, `/=`, `%=`, `//=`, `**=`, `&=`, `|=`, `^=`, `<<=`, `>>=` : İfadeyi sağdaki değerle işleyerek ve sol tarafı güncelleyerek atama, işlem yaparak biriktirme.
        
        - **DİĞER OPERATÖRLER**
            - `()` : Parantezler, ifadeleri gruplandırmak için kullanılır.
            - `[ ]` : Köşeli parantezler, list, tuple ve indeks işlemleri için kullanılır.
            - `{ }` : Süslü parantezler, dictionary ve set tanımlamak için kullanılır.
            - `:` : İki nokta ifadeleri, dilimleri ve sözlüklerde anahtar-değer çiftlerini ayırmak için kullanılır.
            - `,` : Virgül, ifadeleri ayırmak ve veri yapılarını tanımlamak için kullanılır.
    
    - **EN TEMEL İKİ FONKSİYON**
        - `print()`: Ekrana belirtilen değeri veya değerleri yazdırmak için kullanılır.
        - `input()`: Kullanıcıdan veri girişi almak için kullanılır.
    
    - **STRING İFADELER VE METODLAR**
        - String, bir veya daha fazla karakterin (harf, rakam, özel karakter vb.) ardışık bir şekilde sıralandığı veri yapılarıdır. Immutable bir veri türüdür, yani bir kez oluşturulduktan sonra string içeriğinin değiştirilemeyeceği anlamına gelir.
        - String değişkenler tek tırnak veya tek tırnak içerisinde tanımlanır.
            
            ```python
            s1 = 'Hello, world!'    
            s2 = "Python Programming"
            ```
            
        - String Birleştirme
            
            ```python
            d1 = "Hello"
            d2 = "World"
            d3 = s1 + " " + s2   
            print(d3) # Çıktı: "Hello world" 
            ```
            
        - String uzunluğunu alma
            
            ```python
            s = "Burak"
            print(len(s))  # Çıktı: 5 
            ```
            
        - String’lerin dizinlerine erişme ve parçalama
            
            ```python
            s = "Burak" python
            print(s[0])    # Çıktı: 'B' - İlk karakter
            print(s[-1])   # Çıktı: 'k' - Son karakter
            print(s[1:3])  # Çıktı: 'ur' - 1. indeksten 3. indekse kadar (3. indeks dahil değil) parçalayıp ekrana yazdırma
            ```
            
        - `upper()` metodu: String’i tamamen büyük harfe dönüştürür.
            
            ```python
            message = "Hello World"
            print(message.upper())  # "HELLO WORLD"
            ```
            
        - `lower()` metodu: String’i tamamen küçük harfe dönüştürür.
            
            ```python
            message = "Hello World"
            print(message.lower())  # "hello world"
            ```
            
        - `strip()` metodu: String’in başındaki ve sonundaki boşlukları siler.
        - `lstrip()` metodu: String’in sadece başındaki boşlukları siler.
        - `rstrip()` metodu: String’in sadece sonundaki boşlukları siler.
            
            ```python
            message = "   Hello World   "
            print(message.strip())    # "Hello World"
            print(message.lstrip())   # "Hello World   "
            print(message.rstrip())   # "   Hello World"
            
            ```
            
        - `capitalize()` metodu:  String’in ilk karakterini büyük harfe dönüştürür.
            
            ```python
            message = "hello"
            print(message.capitalize())  # "Hello"
            
            ```
            
        - `split()` metodu: String’i belirtilen ayırıcıya göre böler ve bir liste olarak döndürür.
            
            ```python
            message = "ben, niye, varim"
            
            messagelist = message.split(", ")
            print(messagelist)  # ['ben', 'niye', 'varim']
            ```
            
        - String formatlama
            
            ```python
            isim = "Burak"
            yil = 1
            print("Ben {}, programlamayı seviyorum ve {} yıldır Pyhton üzerinde çalışıyorum.".format(isim, yil))
            # "Ben Burak, programlamayı seviyorum ve 1 yıldır Pyhton üzerinde çalışıyorum." çıktısını verir
            ```
            
    
    - **STRING VE NUMERİK İFADELERİN KARŞILAŞTIRILMASI**
        
        ```python
        # Büyüklük Durumu 
        o = 25
        z = 5
        sonuc = o > z # True
        
        # Küçüklük Durumu
        q = 60
        e = 96
        sonuc = q < e # True
        
        # Büyük Eşitlik Durumu 
        a = 15
        b = 10
        sonuc = a >= b # True
        
        # Küçük Eşitlik Durumu 
        m = 5
        c = 5
        sonuc = m <= c # True
        
        # Eşitlik Durumu 
        x = 10
        y = 10
        sonuc = x == y # True
        
        # Eşit Olmama Durumu 
        m = 10
        d = 20
        sonuc = m != d # True
        -------------------------------------
        # BüyükLük Durumu 
        st1 = "deneme"
        st2 = "dene"
        sonuc = st1 > st2  # True
        
        # Küçüklük Durumu
        st3 = "deneme"
        st4 = "dene"
        sonuc = st3 < st4 # False
        
        # Büyük Eşitlik Durumu 
        st5 = "deneme"
        st6 = "dene"
        sonuc = st5 >= st6  # True
        
        # Küçük Eşitlik Durumu 
        st7 = "deneme"
        st8 = "dene"
        sonuc = st7 <= st8  # False
        
        # Eşitlik Durumu 
        st9 = "deneme"
        st10 = "deneme"
        sonuc = st9 == st10  # True
        
        # Eşit Olmama Durumu 
        st11 = "deneme"
        st12 = "dene"
        sonuc = st11 != st12  # True
        ```
        
    
    - **KISA DEVRE (SHORT-CIRCUIT)**
        - Python'da short-circuit (kısa devre) kavramı, bir boolean ifadesinin değerlendirilmesi sırasında, gereksiz işlemlerin atlanması anlamına gelir. Bu, and ve or mantıksal operatörlerle ilgilidir.
            1. `and` operatörü kullanıldığında, ifadenin tamamının doğru (True) olabilmesi için her iki operandın da doğru olması gerekir. İlk operandın yanlış (False) olduğu anlaşılırsa, Python diğer operanda bakmadan sonucun yanlış olduğunu belirler ve değerlendirmeyi durdurur.
                
                ```python
                a = False
                b = True
                
                if a and b:
                    print("Her iki operand da True")
                else:
                    print("Sonuç False çünkü a False")  # Bu satır çalışır
                    
                #Bu durumda a False olduğu için, Python b'yi kontrol etmeden 
                #ifadenin sonucunun False olduğunu belirler.
                ```
                
            2. `or` **operatörü kullanıldığında, ifadenin doğru (True) olabilmesi için herhangi bir operandın doğru olması yeterlidir. İlk operandın doğru (True) olduğu anlaşılırsa, Python diğer operanda bakmadan sonucun doğru olduğunu belirler ve değerlendirmeyi durdurur.
                
                ```python
                a = True
                b = False
                
                if a or b:
                    print("Sonuç True çünkü a True")  # Bu satır çalışır
                else:
                    print("Her iki operand da False")
                
                ```
                
    
    - **KOŞUL İFADELERİ (IF, ELIF, ELSE)**
        - Python'da koşul ifadeleri, programın belirli koşullara bağlı olarak farklı yollar izlemesini sağlar. Koşul ifadeleri, if-elif-else yapılarıyla oluşturulur. Bu ifadeler, belirli bir koşulun True veya False olmasına bağlı olarak farklı kod bloklarının çalıştırılmasını sağlar.
            1. if ifadesi, koşul doğru (True) olduğunda belirli bir kod bloğunu çalıştırır.
                
                ```python
                x = 10
                if x > 5:
                    print("x is greater than 5")  # Bu satır çalışır çünkü x 5'ten büyük.
                ```
                
            2. elif ifadesi, eğer önceki if veya elif koşulları yanlış (False) ise ve elif koşulu doğruysa çalışır. Birden fazla elif ifadesi kullanılabilir.
                
                ```python
                x = 10
                if x > 15:
                    print("x is greater than 15")
                elif x > 5:
                    print("x is greater than 5 but less than or equal to 15")  # Bu satır çalışır
                else:
                    print("x is 5 or less")
                
                ```
                
            3. else ifadesi, tüm if ve elif koşulları yanlış (False) olduğunda çalışır. else bloğu isteğe bağlıdır ve en sona yerleştirilir.
                
                ```python
                x = 3
                if x > 5:
                    print("x is greater than 5")
                else:
                    print("x is 5 or less")  # Bu satır çalışır
                ```
                
        - Koşul ifadeleri, iç içe yerleştirilebilir, yani bir if veya else bloğu içinde başka bir if ifadesi kullanılabilir. Bu tarz yapılar Nested Conditions ismiyle de anılır.
            
            ```python
            x = 10
            y = 20
            
            if x > 5:
                if y > 15:
                    print("x is greater than 5 and y is greater than 15")  # Bu satır çalışır
                else:
                    print("x is greater than 5 but y is 15 or less")
            else:
                print("x is 5 or less")
            ```
            
        - Koşul ifadeleri tek satırda da yazılabilir. Bu, kısa ve basit koşullar için kullanışlıdır ve bu yapıya Ternary Conditional ismi verilir.
            
            ```python
            x = 10
            result = "x is greater than 5" if x > 5 else "x is 5 or less"
            print(result)  # Bu satır "x is greater than 5" yazdırır
            ```
            
        
    
    - **DÖNGÜLER (LOOPS)**
        - Python'da döngüler, belirli bir koşul sağlandığı sürece kodun belirli bir bölümünü tekrar tekrar çalıştırmak için kullanılır. Python'da en yaygın kullanılan döngü yapıları for ve while döngüleridir.
            1. for döngüsü, genellikle bir dizi (liste, tuple, string vb.) veya bir aralık (range) üzerinde yineleme yapmak için kullanılır.
                
                ```python
                # Bu kod, listedeki her bir meyveyi sırasıyla ekrana yazdırır.
                meyveler = ["elma", "muz", "çilek"]
                for meyve in meyveler:
                    print(meyve)
                ```
                
                ```python
                # Bu kod, 0'dan başlayarak 4'e kadar olan sayıları (5 dahil değil) ekrana yazdırır.
                for i in range(5):
                    print(i)
                ```
                
            2. while döngüsü, belirli bir koşul True olduğu sürece kod bloğunu çalıştırır.
                
                ```python
                # Bu kod, i değeri 5'ten küçük olduğu sürece i değerini ekrana yazdırır ve i değerini 1 artırır.
                i = 0
                while i < 5:
                    print(i)
                    i += 1
                ```
                
        - Döngülerin işleyişini daha esnek ve kontrollü hale getirmek için döngü kontrol deyimleri kullanılır. Bunlar döngünün çalışmasını etkileyerek belirli durumlarda döngüyü durdurabilir, atlayabilir veya belirli koşullar altında farklı davranışlar sergilemesini sağlayabilir. Üç farklı döngü kontrol deyimi vardır: “*break*”, “*continue*”.
            1. break deyimi, döngüyü tamamen sonlandırmak için kullanılır. break deyimi çalıştırıldığında, döngü anında durur ve döngüden sonraki koda geçilir.
                
                ```python
                # Bu kod, 0'dan 4'e kadar olan sayıları yazdırır ve i değeri 5 olduğunda döngüyü sonlandırır.
                for i in range(10):
                    if i == 5:
                        break  # Döngüyü sonlandırır.
                    print(i)
                ```
                
            2. continue deyimi, döngünün o anki iterasyonunu atlayarak bir sonraki iterasyona geçmesini sağlar. continue deyimi çalıştırıldığında, döngü bloğunun geri kalan kısmı atlanır ve döngünün başına dönülür.
                
                ```python
                # Bu kod, 0'dan 9'a kadar olan sayılar arasında yalnızca tek sayıları yazdırır.
                for i in range(10):
                    if i % 2 == 0:
                        continue  # Çift sayıları atlar.
                    print(i)
                ```
                

- **CLEAN CODE 1 - 2**
    - **DEĞİŞKEN İSİMLENDİRME**
        - Temiz kodun önemi, yazılım geliştirmenin sadece kodu yazmak değil, onu okuma, anlama, değiştirme ve bakımını yapma işlemini de içerdiği gerçeğinden kaynaklanır. Kodun okunabilirliği ve anlaşılırlığı, kodu yazan kişi ile aynı olmayan kişiler tarafından anlaşılmasını kolaylaştırır.
        - Temiz kodun önemli bir başlığı olan değişken isimlendirmede, anlamlı ve açık isimler, kodun okunabilirliğini artırır ve hataların oluşmasını azaltır. İyi bir değişken ismi, değişkenin neyi temsil ettiğini anlamanıza yardımcı olmalıdır. Değişken isimleri ayrıca ne çok kısa ne de çok uzun olmalıdır. Jargon kullanılmamalı ve standartlara uyulmalıdır.
            
            ```python
            # Kötü değişken isimlendirme
            x1 = "Burak"
            x2 = "Arslan"
            x3 = 30
            
            # İyi değişken isimlendirme
            first_name = "Burak"
            last_name = "Arslan"
            age = 22
            ```
            
        - Boolean değerleri temsil eden değişkenler bir durumu ifade ettiklerinden isimlendirmede is, has, can gibi ön ekler kullanmak kodun anlaşılırlığını artırır.
            
            ```python
            # Kötü değişken isimlendirme
            durum = True
            
            # İyi değişken isimlendirme
             isActive = True
            ```
            
    
    - **STATİK, DİNAMİK VE GENERIC**
        - Programlamada "statik", "dinamik" ve "generic" kavramları, veri tipleri ve bellek yönetimi gibi konularda programlama dillerinin nasıl çalıştığını anlamamıza yardımcı olur.
            1. **Statik Tip Belirleme (Static Typing)**: Statik yapıda değişkenin tipi, derleme zamanında belirlenir ve daha sonra değiştirilemez. Örneğin, C, C++, C# ve Java gibi diller statik tiplidir. Mesela C# dilinde değişken tanımlarken tipini `int sayi = 15` gibi belirtmemiz gerekir.
            2. **Dinamik Tip Belirleme (Dynamic Typing)**: Dinamik yapıda değişkenin tipi, çalışma zamanında belirlenir. Örneğin, Python, JavaScript, PHP gibi diller dinamik tiplidir. Mesela Pyhton dilinde değişken tanımlarken tipini `sayi = 15` gibi belirtmemiz gerekmez.
            3. **Generic** kavramı ise belirli bir veri tipiyle kısıtlanmamış, herhangi bir veri tipi ile çalışabilen yapı ve algoritmaları ifade eder. Bu, kodun tekrar kullanılabilirliğini artırır ve tip güvenliğini sağlar. Ayrıca generic'ler, statik tipli dillerin esneklik kazanmasına yardımcı olur.
                1. Örneğin, Java'da bir list oluştururken, list’in içinde ne tür bir veri tutacağını belirtmeliyiz: `List<String> adlar = new ArrayList<String>();`
                2. Ancak, bu liste sadece String türünde değerleri kabul eder. Eğer bizim bir liste oluşturmamız ve bu listenin farklı türleri kabul etmesi gerekiyorsa, generic'ler devreye girer: `List<?> cesitliliste = new ArrayList<>();`

---

## 2. Hafta

- **GENEL KÜLTÜR**
    - VCS (Version Control System), yazılım geliştirme sürecinde kod değişikliklerini takip eden ve yönetimini sağlayan bir sistemdir. Ekip üyelerinin bağımsız yaptığı değişiklikleri kaydederek, kim tarafından, ne zaman ve neden yapıldığını izler. VCS, değişikliklerin geri alınmasını ve projelerin farklı sürümlerinin yönetilmesini kolaylaştırır.
    
    - Örneğin, Git popüler bir VCS aracıdır ve yazılım projelerinin kaynak kodlarının takip edilmesini sağlar. Diğer VCS araçları arasında SVN ve Mercurial bulunur. Bu sistemler, yazılım geliştirme sürecini daha düzenli ve yönetilebilir kılar.

- **IBM PROFESSIONAL SKILLS 2 (ETKİLİ İŞBİRLİĞİ)**
    - **KONU 1: İŞBİRLİĞİNE İLİŞKİN TEMEL BİLGİLER**
        - İki veya daha fazla kişi ortak bir hedef doğrultusunda birlikte 
        çalıştıklarında, genellikle tek başına çalışarak başarabileceklerinden 
        daha fazlasını başarırlar.
        - Bir başka deyişle, bütün, parçalarının toplamından daha fazlası olabilir.
        - İşbirliği başarılı olduğunda, **1 + 1 = 3 olabilir**.
        - İşverenler, işbirliğini bir beceri olarak vurgular, çünkü günümüzün iş dünyasının çalışanlarından beklentiler arasında: iş gücü çeşitliliğine sahip, küresel ölçekte bağlantılı bir şirkette çalışabilmeleri, karmaşık sorunları aşmaları için müşterilerine yardım edebilmeleri, başarı için sosyal girişim öğelerinden yararlanmaları yer almaktadır.
    
    - **KONU 2: İŞBİRLİĞİNİ GELİŞTİREN DAVRANIŞLAR**
        - İşbirliğine odaklı davranışların sergilenmesi, diğerleriyle çalışma biçiminizi olumlu etkileyebilir. Bunlar: özgün olmak, adil biçimde vermek ve almak, karşılıklı düşünmek, güven kazanmak, tutkulu olmak ve etkili iletişim kurmak.
        - İşbirliğinin önündeki engeller, diğerleri ile çalışma biçiminizi olumsuz etkileyebilir.
        - Diğer davranışlar, makul ölçüler dahilinde sergilendiğinde işbirliği çabalarına yardımcı olurken, aşırıya kaçtığında zarar verebilir. Farkındalık, normal ile aşırı davranışları ayırt etmenize yardımcı olabilir.
    
    - **KONU 3: EKİP İŞBİRLİĞİ**
        - Başarılı ekipler, Oluşum, Beyin Fırtınası, Biçimlenme ve Performans olarak bilinen dört aşamada gelişir.
        - İşbirliğine odaklı davranışlar, ekibinizin dört aşamada ilerlemesine yardımcı olabilir.
    
    - **KONU 4: SANAL İŞBİRLİĞİ**
        - Varsayımlar, tutumlar, inançlar, beklentiler ve değerler gibi bir kişinin kültürünün gözle görülebilir olmayan öğeleri, sanal işbirliğini etkileyebilir.
        - Sanal işbirliğinin zorluklarına (teknik, dil, saat dilimleri ve kültürel) ilişkin farkındalık, bu zorlukları aşmanıza yardımcı olabilir.
        - Sanal işbirliğine özenli ve düşünceli bir biçimde yaklaşın.
    
    - **KONU 5: SANAL İŞBİRLİĞİ ARAÇLARI**
        - Sanal olarak çalışırken uygun işbirliği aracını (e-posta, sohbet, telefon veya sanal toplantı) seçin. Her birinin avantajları ve dezavantajları vardır; hangi görevlerin hangi araçla en iyi şekilde yapıldığını bilin.
        - Sanal işbirliğini iyileştirmek için en son işbirliği araçlarını kullanın. (Google Drive ve Dropbox, Google Docs, Slack, Skype, Mural, Zoom, Teams…)
 
           ![IBM PROFESSIONAL SKILLS 1 GÖRSEL 5](https://github.com/burakarslan0110/IBM-Kodluyoruz-CyberStart/assets/140614856/00ed874c-9612-4038-9075-7ececfed8c80)

        - İşbirliği için sosyal medya araçlarını kullanın.
    
    - **KONU 6: ETKİLİ SANAL TOPLANTILAR**
        - Sanal toplantılarda karşılaşabileceğiniz türdeki sorunların farkında olun, böylece bunlar için planlama yapabilir ve ortaya çıktıklarında bunları çözebilirsiniz.
        - Sanal toplantılarınızı daha etkili hale getirecek stratejiler kullanın.
    

- **IBM PROFESSIONAL SKILLS 2 (KALİTELİ İŞİ ÇEVİK BİR BİÇİMDE TESLİM EDİN)**
    - **KONU 1: İŞİ HAZIRLAYIN**
        - Yapılacak işe hazırlanmak için, görevi net olarak anlamış olmanız gerekir.
        - Bir görevi anlamanızı önleyebilecek faktörleri, örneğin bilgi, kaynak vs. eksikliğini belirleyin.
        - Görevinizi daha iyi anlamak için gereken şekilde sorular sorun.
        - Göreviniz üzerinde çalışmaya başlamak için bir ön eylem planı 
        oluşturun. Planınız, tamamlanma tarihi, önemli aşamalar, ilgili kişiler 
        ve kaynaklar gibi öğeleri kapsamalıdır.
        - Bir çözüme atlamayın! Planlamaya ve açıklığa kavuşturmaya zaman 
        harcayın. Böylece uzun vadede şimdi harcayacağınızdan çok daha fazla 
        zaman kazanabilirsiniz.
    
    - **KONU 2: ARAŞTIRMAYI YAPIN**
        - Araştırmanız, yalnızca doğrudan sizden istenenlerden oluşmamalı, aynı zamanda yararlı olacağını bildiğiniz başka bilgiler de içermelidir. Şunları yaptığınızdan emin olun.
        - Göreviniz üzerinde çalışmak için ilgili bilgileri toplayın.
        - Toplanan bilgileri anlamlı hale getirmek için analiz edin.
        - Toplanan bilgilerin ilgili ve tam olup olmadığını kontrol edin.
    
    - **KONU 3: NE YAPACAĞINIZA KARAR VERİN**
        - Bir görevi tamamlamak için aşağıdakileri yaparak birden fazla çözüm üretebilirsiniz: birden fazla alternatifi araştırmak, kendinizi hayranlık duyduğunuz birinin yerine koymak, deneyimli kişilere benzer durumlarda ne yaptıklarını sormak.
        - Bir görevi tamamlamak için birden fazla çözüm üretmeniz ve üzerinde çalışmaya en elverişli olanı seçmek için çözümleri değerlendirmeniz gerektiğini, aksi halde optimum düzeyin altında çözümler sunma riski ile karşı karşıya kalabileceğinizi unutmayın. Bu, akılların karışmasına ve işin yeniden yapılmasının gerekli olmasına yol açabilir.
    
    - **KONU 4: İŞİ YAPIN**
        - Mesajınızın iletildiğinden emin olmak için planınızı yürütürken dikkatli olun ve iyi düşünerek hareket edin. Eylem planınızı dikkatli ve iyi düşünerek yürütmek için şu adımları takip edin: temel mesajı belirleyin, içeriği filtreleyin, içeriği gözden geçirin, kullanacağınız aracı seçin ve nihai içeriği revize edin.
    
    - **KONU 5: İŞİ TESLİM EDİN**
        - İşinizin çevik bir biçimde teslim edilmesi, işin yapılması ya da planlanması ile aynı ölçüde düşünme ve hazırlanma gerektirir.
        - İşinizi iyi düşünerek ve hazırlıklı bir biçimde teslim etmek için **düşünmeyi, düzenlemeyi ve prova yapmayı** unutmayın.
    

- **PYHTON 2**
    - **LIST (LİSTE)**
        - Python'daki `list` (liste) yapısı, bir veri koleksiyonunu tutmak için kullanılan temel veri tiplerinden biridir. Listeler, sıralı ve değiştirilebilir (mutable) bir yapıdadır. İçinde farklı veri tiplerinden öğeler barındırabilir.
        - Liste oluşturmanın en basit yolu, köşeli parantezler `[]` kullanmaktır.
            
            ```python
            # Boş bir liste
            my_list = []
            
            # Bazı öğeler içeren bir listeler
            numbers = [1, 2, 3, 4, 5]
            fruits = ['apple', 'banana', 'cherry']
            mixed = [1, 'apple', 3.5, True]
            ```
            
        - Listelerdeki öğelere indeks numaraları kullanarak erişilebilir. İndeksler 0'dan başlar.
            
            ```python
            numbers = [10, 20, 30, 40, 50]
            
            # İlk öğeye erişim
            first_element = numbers[0]  # 10
            
            # Son öğeye erişim
            last_element = numbers[-1]  # 50
            
            # İkinci öğeye erişim
            second_element = numbers[1]  # 20
            ```
            
        - Listelerdeki öğeler değiştirilebilir.
            
            ```python
            numbers = [10, 20, 30, 40, 50]
            
            # İkinci öğeyi değiştirme
            numbers[1] = 25
            print(numbers)  # [10, 25, 30, 40, 50]
            ```
            
        - Listelere öğe eklemek ve çıkarmak için çeşitli yöntemler vardır.
            
            ```python
            numbers = [10, 20, 30]
            
            # Liste sonuna öğe ekleme
            numbers.append(40)
            print(numbers)  # [10, 20, 30, 40]
            
            # Belirli bir konuma öğe ekleme
            numbers.insert(1, 15)
            print(numbers)  # [10, 15, 20, 30, 40]
            
            # Belirli bir konumdan öğe kaldırma
            numbers.pop(2)
            print(numbers)  # [10, 15, 30, 40]
            
            # Belirli bir öğeyi kaldırma
            numbers.remove(30)
            print(numbers)  # [10, 15, 40]
            ```
            
        - Python listeleri, birçok kullanışlı metoda sahiptir.
            
            ```python
            numbers = [5, 1, 3, 2, 4]
            
            # Listeyi sırala
            numbers.sort()
            print(numbers)  # [1, 2, 3, 4, 5]
            
            # Listeyi ters çevir
            numbers.reverse()
            print(numbers)  # [5, 4, 3, 2, 1]
            
            # Belirli bir öğenin sayısını al
            count = numbers.count(3)
            print(count)  # 1
            
            # Belirli bir öğenin indeksini al
            index = numbers.index(4)
            print(index)  # 1
            
            # Listedeki tüm ögeleri kaldır
            numbers = [1, 2, 3, 4, 5]
            numbers.clear()
            print(numbers)  # []
            ```
            
        - Bir listenin uzunluğunu öğrenmek için `len` fonksiyonu kullanılır.
            
            ```python
            numbers = [10, 20, 30, 40, 50]
            print(len(numbers))  # 5
            ```
            
        - Listelerin bir alt kümesini almak için dilimleme kullanılır.
            
            ```python
            numbers = [10, 20, 30, 40, 50]
            
            # İlk üç öğeyi al
            subset = numbers[:3]
            print(subset)  # [10, 20, 30]
            
            # Son iki öğeyi al
            subset = numbers[-2:]
            print(subset)  # [40, 50]
            
            # Ortadan bir alt küme al
            subset = numbers[1:4]
            print(subset)  # [20, 30, 40]
            ```
            
        - İki veya daha fazla listeyi birleştirmek için `+` operatörü veya `extend` metodu kullanılabilir.
            
            ```python
            list1 = [1, 2, 3]
            list2 = [4, 5, 6]
            
            # + operatörü ile birleştirme
            combined = list1 + list2
            print(combined)  # [1, 2, 3, 4, 5, 6]
            
            # extend metodu ile birleştirme
            list1.extend(list2)
            print(list1)  # [1, 2, 3, 4, 5, 6]
            ```
            
    
    - **TUPLE (DEMET)**
        - Python'daki `tuple` (demet) yapısı, listeye benzer şekilde sıralı bir veri koleksiyonunu temsil eder ancak önemli bir farkla: tuple'lar değiştirilemez (immutable). Bu, bir tuple oluşturduktan sonra içeriğinin değiştirilemeyeceği anlamına gelir. Tuple'lar, genellikle sabit veri setlerini tutmak ve veri bütünlüğünü korumak için kullanılır.
        - Tuple oluşturmanın en basit yolu, parantez `()` kullanmaktır. Ancak, virgüller tuple oluşturmak için yeterlidir ve parantezler isteğe bağlıdır.
            
            ```python
            # Boş bir tuple
            empty_tuple = ()
            
            # Tek öğeli bir tuple (virgül gereklidir)
            single_element_tuple = (1,)
            
            # Birden fazla öğe içeren tuple
            numbers = (1, 2, 3, 4, 5)
            fruits = ('apple', 'banana', 'orange')
            
            # Parantez olmadan tuple
            mixed = 1, 'orange', 3.5, True
            
            ```
            
        - Tuple öğelerine listelerde olduğu gibi indeks numaraları kullanarak erişilir. İndeksler 0'dan başlar.
            
            ```python
            numbers = (10, 20, 30, 40, 50)
            
            # İlk öğeye erişim
            first_element = numbers[0]  # 10
            
            # Son öğeye erişim
            last_element = numbers[-1]  # 50
            
            # İkinci öğeye erişim
            second_element = numbers[1]  # 20
            ```
            
        - Listelerde olduğu gibi tuple'larda da dilimleme yapabilirsiniz.
            
            ```python
            numbers = (10, 20, 30, 40, 50)
            
            # İlk üç öğeyi al
            subset = numbers[:3]
            print(subset)  # (10, 20, 30)
            
            # Son iki öğeyi al
            subset = numbers[-2:]
            print(subset)  # (40, 50)
            
            # Ortadan bir alt küme al
            subset = numbers[1:4]
            print(subset)  # (20, 30, 40)
            ```
            
        - İki veya daha fazla tuple'ı birleştirmek için `+` operatörü kullanılabilir.
            
            ```python
            tuple1 = (1, 2, 3)
            tuple2 = (4, 5, 6)
            
            # Tuple'ları birleştirme
            combined = tuple1 + tuple2
            print(combined)  # (1, 2, 3, 4, 5, 6)
            ```
            
        - Listeleri tuple'a ve tuple'ları listeye dönüştürmek mümkün.
            
            ```python
            # Listeyi tuple'a dönüştürme
            my_list = [1, 2, 3, 4, 5]
            my_tuple = tuple(my_list)
            print(my_tuple)  # (1, 2, 3, 4, 5)
            
            # Tuple'ı listeye dönüştürme
            my_tuple = (1, 2, 3, 4, 5)
            my_list = list(my_tuple)
            print(my_list)  # [1, 2, 3, 4, 5]
            ```
            
    
    - **DICTIONARY (SÖZLÜK)**
        - Python'daki `dictionary` (sözlük), anahtar-değer (key-value) çiftlerini depolayan değiştirilebilir (mutable) bir veri yapısıdır. Sözlükler, veriye hızlı erişim sağlamak amacıyla hash tabanlı bir yapı kullanır ve bu nedenle anahtarlar benzersiz olmalıdır. Sözlükler, karmaşık veri yapılarını organize etmek ve veriyi anahtarlar aracılığıyla hızlıca bulmak için idealdir.
        - Dictionary oluşturmanın en yaygın yolu süslü parantez `{}` kullanmaktır. Anahtarlar ve değerler iki nokta üst üste `:` ile ayrılır, ve her çift virgülle `,` ayrılır.
            
            ```python
            # Boş bir sözlük
            empty_dict = {}
            
            # Anahtar-değer çiftleri içeren bir sözlük
            person = {
                "name": "Burak",
                "age": 22,
                "city": "Ankara"
            }
            ```
            
        - Sözlükteki değerlere anahtarları kullanarak erişilebilir.
            
            ```python
            person = {
                "name": "Burak",
                "age": 22,
                "city": "Ankara"
            }
            
            # Anahtarı kullanarak değere erişim
            name = person["name"]  # "Burak"
            age = person["age"]  # 22
            
            ```
            
        - Var olan bir anahtarın değerini değiştirebilir veya yeni bir anahtar-değer çifti eklenebilir.
            
            ```python
            person = {
                "name": "Burak",
                "age": 22,
                "city": "Ankara"
            }
            
            # Değeri değiştirme
            person["age"] = 25
            
            # Yeni bir anahtar-değer çifti ekleme
            person["email"] = "burak@example.com"
            
            print(person)
            # {'name': 'Burak', 'age': 25, 'city': 'Ankara', 'email': 'burak@example.com'}
            ```
            
        - Sözlükten bir anahtar-değer çiftini kaldırmak için `del` anahtar kelimesi veya `pop` metodu kullanılabilir.
            
            ```python
            person = {
                "name": "Burak",
                "age": 22,
                "city": "Ankara"
            }
            
            # del ile anahtar-değer çiftini kaldırma
            del person["age"]
            
            # pop ile anahtar-değer çiftini kaldırma ve değeri döndürme
            city2 = person.pop("city")
            
            print(person)  # {'name': 'Burak'}
            print(city2)  # "Ankara"
            ```
            
        - Dictionary, çeşitli kullanışlı metotlara sahip.
            
            ```python
            person = {
                "name": "Burak",
                "age": 22,
                "city": "Ankara"
            }
            
            # Tüm anahtarları almak
            keys = person.keys()
            print(keys)  # dict_keys(['name', 'age', 'city'])
            
            # Tüm değerleri almak
            values = person.values()
            print(values)  # dict_values(['Burak', 22, 'Ankara'])
            
            # Tüm anahtar-değer çiftlerini almak
            items = person.items()
            print(items)  # dict_items([('name', 'Burak'), ('age', 22), ('city', 'Ankara')])
            
            # Sözlüğü temizlemek
            person.clear()
            print(person)  # {}
            ```
            
    
    - **SET (KÜME)**
        - Python'daki `set` (kümeler) yapısı, benzersiz (unique) öğelerden oluşan, sırasız ve değiştirilebilir (mutable) bir veri yapısıdır. Setler, matematiksel kümelere benzer şekilde çalışır ve aynı öğeden birden fazla bulunmasına izin vermezler.
        - Set oluşturmanın en yaygın yolu süslü parantez `{}` kullanmaktır. Ancak, boş bir set oluşturmak için `set()` fonksiyonu kullanılmalıdır, çünkü `{}` boş bir dictionary (sözlük) oluşturur.
            
            ```python
            # Boş bir set
            empty_set = set()
            
            # Bazı öğeler içeren bir set
            fruits = {"apple", "banana", "cherry"}
            
            # Tekrarlı öğeler içeren bir set (tekrarlar otomatik olarak kaldırılır)
            numbers = {1, 2, 2, 3, 4, 4, 5}
            print(numbers)  # {1, 2, 3, 4, 5}
            ```
            
        - Setlerde belirli bir öğeye indeksle erişim yoktur çünkü setler sırasızdır. Ancak, belirli bir öğenin sette olup olmadığını `in` anahtar kelimesiyle kontrol edebiliriz.
            
            ```python
            fruits = {"apple", "banana", "orange"}
            
            # Belirli bir öğenin varlığını kontrol etme
            is_apple_in_fruits = "apple" in fruits  # True
            is_orange_in_fruits = "cherry" in fruits  # False
            ```
            
        - Setlere öğe eklemek ve setlerden öğe kaldırmak için çeşitli yöntemler vardır.
            
            ```python
            fruits = {"apple", "banana"}
            
            # Sete öğe ekleme
            fruits.add("cherry")
            print(fruits)  # {'apple', 'banana', 'cherry'}
            
            # Setten belirli bir öğeyi kaldırma
            fruits.remove("banana")
            print(fruits)  # {'apple', 'cherry'}
            
            # Setten bir öğeyi güvenli bir şekilde kaldırma (öğe yoksa hata vermez)
            fruits.discard("banana")  # {'apple', 'cherry'}
            
            # Setten rastgele bir öğe çıkarma ve döndürme
            popped_fruit = fruits.pop()
            print(popped_fruit)  # Rastgele bir öğe (örneğin, 'apple')
            print(fruits)  # Kalan öğeler (örneğin, {'cherry'})
            
            # Seti temizleme (tüm öğeleri kaldırma)
            fruits.clear()
            print(fruits)  # set()
            ```
            
        - Setler, matematiksel küme işlemlerini destekler. Bunlar arasında birleşim (union), kesişim (intersection), fark (difference) ve simetrik fark (symmetric difference) bulunur.
            
            ```python
            set1 = {1, 2, 3, 4}
            set2 = {3, 4, 5, 6}
            
            # Birleşim
            union_set = set1.union(set2)
            print(union_set)  # {1, 2, 3, 4, 5, 6}
            
            # Kesişim
            intersection_set = set1.intersection(set2)
            print(intersection_set)  # {3, 4}
            
            # Fark
            difference_set = set1.difference(set2)
            print(difference_set)  # {1, 2}
            
            # Simetrik fark
            symmetric_difference_set = set1.symmetric_difference(set2)
            print(symmetric_difference_set)  # {1, 2, 5, 6}
            ```
            
        - Python set yapıları, kullanışlı metotlara sahiptir.
            
            ```python
            set1 = {1, 2, 3}
            set2 = {3, 4, 5}
            
            # Set1'in set2'yi kapsayıp kapsamadığını kontrol etme
            is_superset = set1.issuperset(set2)  # False
            
            # Set1'in set2'deki tüm öğeleri içerip içermediğini kontrol etme
            is_subset = set1.issubset(set2)  # False
            
            # İki setin ayrık olup olmadığını kontrol etme (ortak öğeleri yok mu)
            is_disjoint = set1.isdisjoint(set2)  # False
            
            # Seti kopyalama
            set_copy = set1.copy()
            print(set_copy)  # {1, 2, 3}
            ```
            
    
    - **NON-SCALAR VERİ TİPLERİNE FOR DÖNGÜSÜ**
        - List üzerinde `for` döngüsü kullanarak her bir öğeye sırasıyla erişebiliriz.
            
            ```python
            fruits = ["apple", "banana", "cherry"]
            
            for fruit in fruits:
                print(fruit)
                    
            #apple
            #banana
            #cherry
            ```
            
        - Dictionary üzerinde `for` döngüsü kullanarak anahtarları, değerleri veya anahtar-değer çiftlerini iterasyonla elde edebiliriz.
            
            ```python
            # Anahtarlar üzerinde iterasyon
            person = {"name": "Burak", "age": 22, "city": "Ankara"}
            
            for key in person:
                print(key)
            
            #name
            #age
            #city
            
            #-------------------------
            
            # Değerler üzerinde iterasyon
            person = {"name": "Burak", "age": 22, "city": "Ankara"}
            
            for value in person.values():
                print(value)
            
            #Burak
            #22
            #Ankara
            
            #-------------------------
            
            person = {"name": "Burak", "age": 22, "city": "Ankara"}
            
            for key, value in person.items():
                print(f"{key}: {value}")
            
            #name: Burak
            #age: 22
            #city: Ankara
            ```
            
        - Set üzerinde `for` döngüsü kullanarak her bir öğeye sırasıyla erişebiliriz. Kümelerde öğeler sırasızdır, bu yüzden çıktının sırası garanti edilmez.
            
            ```python
            numbers = {1, 2, 3, 4, 5}
            
            for number in numbers:
                print(number)
            ```
            
        - Tuple üzerinde `for` döngüsü kullanarak her bir öğeye sırasıyla erişebilirsiniz. Tuple’lar sıralı bir yapıdadır.
            
            ```python
            coordinates = (10, 20, 30)
            
            for coordinate in coordinates:
                print(coordinate)
            
            #10
            #20
            #30
            ```
            
    
    - **LIST COMPREHENSION**
        - List Comprehension, liste oluşturmanın kısa ve okunaklı bir yolu olduğunu söyleyebiliriz. Tek bir satırda yeni bir liste oluşturmayı sağlar ve bir listeyi başka bir listeye dönüştürmek, belirli bir koşula göre filtrelemek ve öğeleri dönüştürmek için kullanılır.
        - `[expression for item in iterable]` yapısıyla kullanılır.
            
            ```python
            # 0'dan 9'a kadar olan sayıları içeren bir liste oluşturma
            numbers = [x for x in range(10)]
            print(numbers)  # Çıktı: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
            ```
            
    
    - **VARIABLE UNPACKING**
        - Variable Unpacking, Python'da veri yapılarını (list, tuple, dictionary) parçalayıp öğeleri ayrı değişkenlere atamak için kullanılan güçlü ve esnek bir tekniktir. Bu yöntem, kodu daha temiz ve okunabilir hale getirir, fonksiyonlarla ve veri yapılarıyla çalışmayı kolaylaştırır.
            
            ```python
            fruits = ["apple", "banana", "cherry"]
            a, b, c = fruits
            
            print(a)  # Çıktı: apple
            print(b)  # Çıktı: banana
            print(c)  # Çıktı: cherry
            ```
            
    
    - **ENUMERATE VE ZIP FONKSİYONLARI**
        - Python'da `enumerate` ve `zip` fonksiyonları, iterasyon işlemlerini daha kolay ve okunabilir hale getiren güçlü araçlardır.
        1. `enumerate` fonksiyonu, bir iterable (örneğin, list veya tuple) üzerinde iterasyon yaparken, her öğenin indeksini ve öğenin kendisini birlikte döner. Bu, döngülerde indeksi takip etmeyi kolaylaştırır. `enumerate` fonksiyonu temelde şu şekilde kullanılır: 
            
            ```python
            malzemeler = ["kitap", "defter", "kalem"]
            
            for index, malzeme in enumerate(malzemeler):
                print(index, malzeme)
            ```
            
        2. `zip` fonksiyonu, birden fazla iterable'ı paralel olarak iterasyon yapmaya olanak tanır. `zip`, öğeleri bir araya getirir ve bir tuple listesi döner. Bu, aynı indeksli öğeleri bir araya getirmeyi sağlar. `zip` fonksiyonu temelde şu şekilde kullanılır:
            
            ```python
            names = ["Ahmet", "Cansu", "Melih"]
            ages = [25, 30, 35]
            
            for name, age in zip(names, ages):
                print(f"{name}, {age} yaşında")
            ```
            
        
    
    - **FONKSİYONLAR**
        - Python'da fonksiyonlar, belirli bir görevi yerine getirmek için tanımlanan ve tekrar tekrar kullanılabilen kod bloklarıdır. Bu yapılar, kodu daha düzenli, okunabilir ve tekrar kullanılabilir hale getirir.
        - Python'da bir fonksiyon tanımlamak için `def` anahtar kelimesi kullanılır. Bir fonksiyonun genel yapısı şu şekildedir:
            
            ```python
            def fonksiyon_adi(parametre1, parametre2, ...):
                # Fonksiyonun gövdesi
                # Yapılacak işlemler burada tanımlanır
                return ifade
            ```
            
        - Örneğin aldığı iki sayının toplamını döndüren bir fonksiyon tasarlayalım ve bunu kullanalım.
            
            ```python
            def toplama(a, b):
                sonuc = a + b
                return sonuc
             
            n = toplama(3, 5)
            print(n)  # Çıktı: 8
            ```
            
        - Her fonksiyon `return` anahtar kelimesiyle yaptığı işlemden ürettiği değeri geri döndürmek zorunda değildir. Bazı fonksiyonlar sadece bir işlemi gerçekleştirmek üzere tasarlanmıştır ve geriye değer döndürmez. Bunlara void fonksiyonlar denir, return ifadesi kullanılmaz.
            
            ```python
            def merhaba_yazdir():
                print("Merhaba, Dünya!")
            
            merhaba_yazdir()
            ```
            
        - Eğer bir fonksiyon çağrıldığında bu parametreler için bir değer verilmezse, daha önceden belirlenmiş varsayılan değerlerin kullanılmasını isteyebiliriz.
            
            ```python
            def selamla(isim="Dünya"): #Fonksiyon argüman verilmeden çağrılırsa "Dünya" değeri kullanılır.
                print(f"Merhaba, {isim}!")
            
            selamla()          # Çıktı: Merhaba, Dünya!
            selamla("Ali")     # Çıktı: Merhaba, Ali!
            ```
            
        - Fonksiyonların ayrıca parametre olarak alacağı değerlerin sayısı değişken olabilir. Örneğin toplama işlemi yapması için bir fonksiyona ikiden fazla sayı gönderebiliriz.
            
            ```python
            def topla(*args):
                toplam = 0
                for sayi in args:
                    toplam += sayi
                return toplam
            
            print(topla(1, 2, 3, 7))  # Çıktı: 13
            print(topla(1, 2, 3, 4, 5, 6, 7, 8, 9))  # Çıktı: 45
            ```
            

- **CLEAN CODE 3 - 4**
    - **YENİDEN KULLANILABİLİRLİK VE DRY PRENSİBİ**
        - Yeniden kullanılabilirlik, yazdığınız kodun farklı yerlerde ve projelerde tekrar kullanılabilmesidir. Bu, kod miktarını azaltır, okunabilirliği ve bakımını kolaylaştırır. Ayrıca, hata durumunda düzeltilecek kod miktarını da azaltır.
        - DRY prensibi, "Kendini Tekrarlama" (Don't Repeat Yourself) anlamına gelir ve "Her bilginin tek ve kesin bir temsili olmalıdır" şeklinde ifade edilir. Bu yaklaşım aynı kod parçacığının tekrarlanmasını önler, kodların bakımını kolaylaştırır ve hataları azaltır.
            
            ```csharp
            using System;
            
            class Program
            {
                static void Toplama()
                {
                    int sayi1 = 5;
                    int sayi2 = 7;
                    int sonuc = sayi1 + sayi2;
                    Console.WriteLine("Toplama sonucu: " + sonuc);
                }
            
                static void Carpma()
                {
                    int sayi1 = 5;
                    int sayi2 = 7;
                    int sonuc = sayi1 * sayi2;
                    Console.WriteLine("Çarpma sonucu: " + sonuc);
                }
            
                static void Main(string[] args)
                {
                    Toplama();
                    Carpma();
                }
            }
            ```
            
        - C# ile yukarıda yazılmış örnekte DRY prensibine aykırılık söz konusudur. Zira, sayi1 ve sayi2 değerleri hem Toplama hem de Carpma fonksiyonlarında tekrarlanıyor. İdeal olarak, bu iki fonksiyonu tek bir fonksiyonda birleştirmeliyiz:
            
            ```csharp
            using System;
            
            class Program
            {
                static void Hesaplama(int sayi1, int sayi2)
                {
                    int toplam = sayi1 + sayi2;
                    int carpim = sayi1 * sayi2;
                    Console.WriteLine("Toplama sonucu: " + toplam + ", Çarpma sonucu: " + carpim);
                }
            
                static void Main(string[] args)
                {
                    Hesaplama(5, 7);
                }
            }
            ```
            
        - Bu kod, daha kısa ve daha yeniden kullanılabilir. Farklı sayılarla hesaplamalar yapmak istediğimizde, sadece Hesaplama fonksiyonunu yeni sayılarla çağırabiliriz. Bu, kodumuzu DRY tutar ve bakımını kolaylaştırır.
    
    - **TEK SORUMLULUK İLKESİ**
        - Bir kod parçasının temiz ve anlaşılır olması için birçok strateji bulunmaktadır, ancak en önemlilerinden biri Tek Sorumluluk İlkesi'dir (Single Responsibility Principle - SRP).
        - Tek Sorumluluk İlkesi, yazılım geliştirme dünyasında SOLID prensiplerinin temel taşlarından biridir. Bu ilke, bir sınıf veya fonksiyonun yalnızca tek bir sorumluluğu olması gerektiğini savunur. Başka bir deyişle, bir sınıf veya fonksiyon sadece bir işi yapmalı ve bu işi en iyi şekilde yapmalıdır.
        - Örneğin aşağıda bir kullanıcının yaptığı işlemleri log kaydına alan ve ayrıca bu işlemler sonucunda elde edilen toplam miktarı hesaplayan program, Tek Sorumluluk İlkesi’ne uymamaktadır. Çünkü iki farklı işlemi tek metod gerçekleştiriyor.
            
            ```csharp
            using System;
            
            public class Program
            {
                // Toplama işlemi ve log kaydı işlemlerini gerçekleştiren metod
                public static void ToplamaVeLogKaydi(int sayi1, int sayi2)
                {
                    int sonuc = sayi1 + sayi2;
                    Console.WriteLine($"{sayi1} + {sayi2} = {sonuc} işlemi yapıldı.");
                }
            
                public static void Main()
                {
                    int sayi1 = 5, sayi2 = 7;
                    ToplamaVeLogKaydi(sayi1, sayi2);
                }
            }
            ```
            
        - Aşağıdaki örnekte ise `Toplama` metodu sadece toplama işlemini yapar ve `LogKaydi` metodu ise sadece log kaydı oluşturur. Her metod kendi sorumluluğunu en iyi şekilde yerine getirir ve söz konusu ilkeye uygundur.
            
            ```csharp
            using System;
            
            public class Program
            {
                // Toplama işlemi metod
                public static int Toplama(int sayi1, int sayi2)
                {
                    return sayi1 + sayi2;
                }
            
                // Log kaydı metod
                public static void LogKaydi(int sayi1, int sayi2, int sonuc)
                {
                    Console.WriteLine($"{sayi1} + {sayi2} = {sonuc} işlemi yapıldı.");
                }
            
                public static void Main()
                {
                    int sayi1 = 5, sayi2 = 7;
                    int sonuc = Toplama(sayi1, sayi2);
                    LogKaydi(sayi1, sayi2, sonuc);
                }
            }
            ```
            

---

## 3. Hafta

- **GENEL KÜLTÜR: BAZI PROGRAMLAMA DİLLERİNE UZAKTAN BAKIŞ**
    - **C#**, Microsoft tarafından geliştirilen ve .NET framework üzerinde çalışan, nesne yönelimli bir programlama dilidir. Basit, modern, genel amaçlı ve tür güvenli bir dil olarak tasarlanmıştır. C#, güçlü tipi sistemi, çöp toplama mekanizması ve geniş kütüphane desteği ile yazılım geliştirme süreçlerini kolaylaştırırken, C, C++ ve Java gibi dillere benzer bir sözdizimi sunarak programcılar için öğrenmesi ve kullanması nispeten kolaydır.
    
    - **Java**, Sun Microsystems tarafından geliştirilen ve şu anda Oracle tarafından sürdürülen, platformdan bağımsız, nesne yönelimli bir programlama dilidir. "Bir kere yaz, her yerde çalıştır" prensibiyle tasarlanmış olan Java, yazılan kodların herhangi bir platformda çalışabilmesini sağlar. Bu, Java'nın kendine özgü sanal makinesi (JVM) aracılığıyla gerçekleştirilir. Java, geniş kütüphane ve API desteği sayesinde web, mobil, masaüstü ve sunucu tabanlı uygulamalar geliştirmeye olanak tanır.
    
    - **JavaScript**, web tarayıcılarında dinamik içerik oluşturmak için kullanılan, prototip tabanlı, nesne yönelimli bir programlama dilidir. HTML ve CSS ile birlikte webin temel teknolojilerinden biri olan JavaScript, kullanıcı etkileşimlerini yönetmek ve web uygulamaları geliştirmek için kullanılır. Geniş kütüphane ve framework desteği sayesinde modern web geliştirmede önemli bir rol oynar.
    
    - **Python**, Guido van Rossum tarafından geliştirilen, basit ve okunabilir sözdizimiyle tanınan, yüksek seviyeli, genel amaçlı bir programlama dilidir. Hem başlangıç seviyesindeki programcılar hem de deneyimli geliştiriciler için uygun olan Python, geniş kütüphane ve framework desteği sayesinde web geliştirme, veri analizi, yapay zeka, bilimsel hesaplama ve daha birçok alanda yaygın olarak kullanılır.
    
    - **PHP** (Hypertext Preprocessor), dinamik web siteleri ve uygulamaları geliştirmek için kullanılan, sunucu taraflı, açık kaynaklı bir programlama dilidir. İlk olarak Rasmus Lerdorf tarafından oluşturulan PHP, HTML ile kolayca entegre edilebilir ve geniş veri tabanı desteği sunar. Esnek ve öğrenmesi kolay olan PHP, özellikle web geliştirme alanında yaygın olarak kullanılır ve WordPress gibi popüler içerik yönetim sistemlerinin temelini oluşturur.
    
    - **C**, Dennis Ritchie tarafından Bell Labs'ta geliştirilen, genel amaçlı, düşük seviyeli bir programlama dilidir. Sistem programlama için tasarlanmış olan C, doğrudan makine koduna yakın düzeyde çalışabilme yeteneği sağlar ve bu özelliğiyle işletim sistemleri, sürücüler gibi uygulamalar için idealdir. Aynı zamanda taşınabilirliği ve geniş kütüphane desteği sayesinde birçok farklı platformda kullanılabilir. C, C++ ve Java gibi modern dillerin temelini oluşturmuş ve programlama dünyasında önemli bir yer edinmiştir.
    
    - **C++**, C programlama dilinin nesne yönelimli özelliklerle genişletilmiş bir sürümüdür. Bjarne Stroustrup tarafından geliştirilmiştir ve karmaşık yazılımların geliştirilmesi için kullanılır. Nesne yönelimli programlama yeteneklerine ek olarak, şablonlar, yüksek performanslı uygulamalar, oyunlar için idealdir.
    

- **GENEL KÜLTÜR**
    - ChatGPT ve diğer büyük dil modellerini daha efektif kullanmak için kılavuz niteliğinde repo: [Awesome ChatGPT Prompts](https://github.com/f/awesome-chatgpt-prompts)

- **IBM EXPLORE EMERGING TECH 1 (BULUT, YAPAY ZEKA VE SİBER GÜVENLİK)**
    - **BULUT BİLİŞİM NEDİR?**
        - Bulut bilişim, internet üzerinden sunulan ve bilgisayarlar, sunucular, veri depolama, ağlar, yazılımlar ve daha fazlası gibi BT kaynaklarına erişim imkanı veren bir teknolojidir. Kullanıcılar veya kurumlar bu kaynakları satın almak yerine kiralayarak esneklik ve maliyet tasarrufu sağlayabilirler.
        
        - Bulut bilişim, bireyler ve kuruluşlar için birçok avantaj sunar. Bunlardan bazıları şunlardır:
            - **Erişilebilirlik:** Herhangi bir internet bağlantısına sahip herhangi cihazdan bulut kaynaklarına erişebilirsiniz.
            - **Ölçeklenebilirlik:** İhtiyaçlarınıza göre kaynaklarınızı kolayca artırabilir veya azaltabilirsiniz.
            - **Maliyet tasarrufu:** Altyapı yatırımına gerek kalmadan, kullandığınız kadar ödersiniz.
            - **Esneklik:** Farklı bulut modelleri ve hizmetleri arasından seçim yapabilirsiniz.
            - **Güvenlik:** Güvenli ve sağlam veri merkezlerinde barındırılan bulut kaynakları, geleneksel altyapılara kıyasla daha güvenlidir
        
        - Genel, özel ve hibrit bulut olmak üzere üç farklı bulut türü vardır:
            1. **Genel bulut**, müşterilerinin düşük maliyetli bilgi işlem kaynaklarına hızla erişmelerine olanak sağlayan şirketlere aittir ve bu şirketler tarafından işletilir. Bu, küçük işletmelerin ve bireysel kullanıcıların İnternet üzerinden çok yüksek bilgi işlem gücüne erişebilecekleri klasik bulut bilişim modelidir.
            2. **Özel bulut**, sadece bir organizasyon tarafından kullanılan ve o organizasyonun kontrolünde olan bulut altyapısıdır. Bu, şirket içi veri merkezinde veya üçüncü parti bir hizmet sağlayıcı tarafından barındırılabilir. Yüksek güvenlik, veri kontrolü, özel donanım ve yazılım kullanımı ile özelleştirme imkanı sağlarlar. Genellikle daha yüksek maliyetli olup, kaynaklar tek bir muhataba özeldir.
            3. **Hibrit bulut** ise hem genel hem de özel bulutların kombinasyonudur ve iki ortam arasında veri ve uygulamaların taşınmasına olanak tanır. Bu modelde Esneklik ve ölçeklenebilirlik söz konusudur. Hassas veriler özel bulutta tutulabilirken, daha az hassas işlemler ve büyük ölçekli uygulamalar genel bulutta çalıştırılabilir. Yüksek veri güvenliği gerektiren ve aynı zamanda yüksek performans ve ölçeklenebilirlik isteyen kuruluşlar için oldukça idealdir.

                ![IBM EXPLORE EMERGING TECH 1 GÖRSEL 1](https://github.com/burakarslan0110/IBM-Kodluyoruz-CyberStart/assets/140614856/936fc358-5273-4e08-bf00-fa97acbda5ac)

        
        - Bulut türleri üçe ayrıldığı gibi bu türlerin kullanıcılara ve kuruluşlara sunuluş şekli de üçe ayrılıyor. Bulut bilişimin en popüler üç hizmet modelini şu şekilde ele alabiliriz:
            1. Hizmet olarak sunulan yazılım (SaaS): Yazılım uygulamalarının internet üzerinden sunulmasıdır. Kullanıcılar, yazılıma web tarayıcılarıyla erişir ve genellikle abonelikle kullanırlar. Yazılımın kurulumu, bakımı ve güncellemeleri hizmet sağlayıcı tarafından yapılır, böylece kullanıcılar her zaman en güncel sürüme erişebilir. **SaaS'yi bir başkasının mutfağı olarak düşünebilirsiniz. Çevrimiçi olursunuz ve siparişinizi verirsiniz. Size tarifi verirler, yemeği pişirirler ve size sunarlar.**
            2. Hizmet olarak sunulan platform (PaaS): Kullanıcıların uygulama geliştirme, test etme, dağıtma ve yönetme için gerekli araç ve hizmetleri sunan bir bulut hizmeti modelidir. PaaS, altyapı yönetimini hizmet sağlayıcısına bırakarak geliştiricilerin uygulama geliştirmeye odaklanmasını sağlar. **PaaS'yi bir başkasının mutfağı olarak düşünebilirsiniz. Ancak malzemeleri ve tarifi siz sağlarsınız ve pişirmeyi de siz yaparsınız.**
            3. Hizmet olarak sunulan altyapı (IaaS): İnternet üzerinden bilgi işlem altyapısı kaynaklarına erişimini sağlayan bir bulut hizmeti modelidir. IaaS, sanal sunucular, depolama, ağ ve işletim sistemleri gibi temel bilgi işlem kaynaklarını içerir ve bunları talebe göre ölçeklenebilir şekilde sunar. **IaaS'yi kendi mutfağınız olarak düşünebilirsiniz. Burada tarifi kendiniz sağlar ve pişirmeyi de kendiniz yaparsınız. Ancak, beyaz eşyanızın bakımı ve aletlerinizin yönetimi başka biri tarafından sağlanır.**

               ![IBM EXPLORE EMERGING TECH 1 GÖRSEL 2](https://github.com/burakarslan0110/IBM-Kodluyoruz-CyberStart/assets/140614856/bd7e5e50-99b0-4114-9408-b09e7ed827d8)

    - **YAPAY ZEKA NEDİR?**
        - Yapay zeka (YZ), bilgisayarların insan benzeri zekâ sergilemesini sağlamak amacıyla geliştirilen teknolojiler ve algoritmalar bütünüdür. YZ, bilgisayarların öğrenme, akıl yürütme, problem çözme, anlama, planlama ve doğal dil işleme gibi bilişsel işlevleri yerine getirebilmesini amaçlar. Yapay zekanın temel hedefi, makinelerin karmaşık görevleri otomatik olarak gerçekleştirebilmesini ve kararlar alabilmesini sağlamaktır.
        
        - Yapay zekalar seviyelerine göre üçe ayrılır:
            1. **Zayıf yapay zeka**, belirli bir görevi veya dar bir görev kümesini yerine getirmek üzere tasarlanmış yapay zeka sistemleridir. Bu tür yapay zekalar, insanlar tarafından programlanmış belirli kuralları ve algoritmaları takip eder. Spesifik görevleri etkili bir şekilde yerine getirmek dışında herhangi bir ekstra işlevleri yoktur.  Siri ve Alexa gibi sesli komutları anlayan dijital asistanlar zayıf yapay zekanın örnekleri arasındadır.
            2. **Artırılmış zeka**, yapay zeka teknolojilerinin insan yeteneklerini tamamlayarak ve güçlendirerek daha iyi kararlar almalarını sağlamayı amaçlayan bir yaklaşımdır. Bu konsept, yapay zekanın insanların yerini almasını değil, onlarla işbirliği yaparak insanların becerilerini ve yeteneklerini artırmasını hedefler. Örneğin sağlık alanında doktorların hastalık teşhisinde ve tedavi planlamasında yapay zekanın sunduğu verileri ve analizleri kullanması artırılmış zekaya örnektir.
            3. Henüz icat edilmeyen ama üzerinde çalışmaların sürdürüldüğü **Genel Yapay Zeka** ise insan benzeri zekâ ve bilişsel yetenekleri tamamen veya büyük ölçüde simüle etmeyi amaçlar. “Tam beyin emülasyonu” olarak da anılan bu yapay zekanın, karmaşık karar verme yeteneğine ve farklı görevleri kendi başına yürütebilme becerisine sahip olacak şekilde tasarlanacağı düşünülse de günümüzden on beş, yirmi sonra hayatımıza gireceği tahmin ediliyor. 
        
        - Yapay zeka ilgi alanlarına göre de şu üç dalda incelenebilir.
            1. **Yapay Zeka (AI)**: Genellikle insan zekasıyla ilişkilendirilen yetenekleri kullanan makineleri tanımlar. Günümüzdeki yapay zeka çalışmaları; öğrenme, mantık yürütme, sorun çözme, algılama ve insan dilini anlamaya odaklanır
            2. **Makine öğrenimi** (ML): Makine öğrenmesi, bilgisayar sistemlerinin verilerden öğrenme yapabilmesi ve deneyimlerden yararlanarak kendini geliştirebilmesi için kullanılan bir yapay zeka yaklaşımıdır. Ayrıca makine öğrenmesi, yapay zekanın bir alt kümesidir. 
            3. **Derin öğrenme** (DL), problem çözerken istatistik modellerine odaklanan bir makine öğrenimi alt kategorisidir. Binlerce kez görevleri tekrar tekrar yerine getirip sonucu iyileştirmek adına her seferinde biraz değiştirerek karmaşık problemleri çözmek için insan beyninden ilham alan algoritmalardan oluşan yapay bir sinir ağı kullanır. Derin öğrenme büyük veri ve devasa bir bilişim gücü gerektirir, ancak genel yapay zeka hedefine giden yolda muazzam bir potansiyele sahiptir.

                ![IBM EXPLORE EMERGING TECH 1 GÖRSEL 3](https://github.com/burakarslan0110/IBM-Kodluyoruz-CyberStart/assets/140614856/1987aa8d-6af9-4c6b-995e-70473c0e71ae)
    
    - **SİBER GÜVENLİK NEDİR?**
        - Siber güvenlik, bilgi teknolojileri ve internet ortamında bulunan bilgi sistemlerini, verileri ve kullanıcıların dijital varlıklarını kötü niyetli saldırılardan koruma sürecidir. Temel amacı, bilgisayar sistemlerinin, ağların, yazılımların ve verilerin güvenliğini sağlamak ve bu sistemlerin doğruluğunu, erişilebilirliğini ve gizliliğini korumaktır.
        
        - Kimlik doğrulaması, bir bilgisayarın, kiminle etkileşim kurduğunu anlamasına olanak sağlayan bir süreci ifade eder. Bildiğiniz, sahip olduğunuz ve size ait olan bir şeye dayalı olmak üzere üç farklı kimlik doğrulaması türü vardır.
        
        - Güvenlik uzmanları, genellikle önemli hesaplar için iki veya daha fazla kimlik doğrulaması türü (iki faktörlü ya da çok faktörlü kimlik doğrulaması) kullanılmasını önerir.
        
        - İzinler ya da Erişim Kontrol Listeleri (ACL), her kullanıcının bir bilgisayardaki herhangi bir dosyayı, klasörü veya programı görüntülemek ya da değiştirmek için sahip olduğu erişim yetkisini ifade eder.
        
        - Malware adı verilen kötü amaçlı yazılımlar, bir programı veya bilgi işlem sistemini kullanıcı verilerini kopyalayan ve bilgisayar korsanlarının kullanıcının yerine geçmesine olanak sağlayan saldırılara karşı savunmasız hale gelmesine yol açabilir.
        
        - Bilgisayar korsanları, bilgisayar sistemlerine girmek için teknik bilgi birikimlerini kullanırlar. Siyah Şapkalı bilgisayar korsanları, bilgisayar güvenlik açıklarını ve verileri çalmak, istismar etmek ve satmak gibi kötü amaçlara sahiptir.
        
        - Beyaz Şapkalı bilgisayar korsanları ise sistemleri daha güvenli ve daha dayanıklı hale getirmek amacıyla güvenlik değerlendirmeleri gerçekleştirmek, hataları aramak ve yazılımlardaki güvenlik boşluklarını doldurmak üzere şirketler ve devletler tarafından görevlendirilir.
        
        - Yazılımları yaratanların bilgi sahibi olmadığı yeni bir istismar edilebilir hata, sıfır-gün güvenlik açığı olarak anılır. Siyah Şapkalı bilgisayar korsanları, Beyaz Şapkalı programcılar bu hata için bir yama yayınlayamadan en yüksek düzeyde avantaj elde etmek amacıyla bu istismardan yararlanmak için yarışırlar.
        
        - En yaygın bilgisayar güvenliği biçimleri, şifreleme olarak bilinir. Sistem mimarları, saldırganları hayal kırıklığına uğratmak için bu stratejilerden yararlanarak bilgileri gizler.
        
        - Şifre, düz metni şifreli metne dönüştüren bir algoritmadır ve şifreyi çözmenize olanak sağlayan anahtara sahip değilseniz bu şifreli metnin herhangi bir anlamı yoktur. Metnin gizli hale getirilmesi sürecine şifreleme ve tersi sürece şifre çözme adı verilir.
        
        - Şifreleme yöntemleri, hem gönderici hem de alıcı tarafından bilinen anahtarlardan yararlanır. Gönderici, anahtarı kullanarak bir mesajı şifreler ve alıcı, aynı anahtarı kullanarak bu mesajın şifresini çözer.
        
        - Mesajların şifrelenmesi ve şifrenin çözülmesi için hem gönderici hem de alıcı tarafından kullanılabilen anahtarlar, anahtarın her iki tarafta aynı olması nedeniyle simetrik anahtar olarak anılır.
        
        - Asimetrik şifreleme, genellikle biri ortak ve biri özel olmak üzere iki farklı anahtar kullanır. Göndericiler, yalnızca alıcının kendi özel anahtarıyla şifresini çözebileceği bir iletiyi, ortak anahtar kullanarak şifreleyebilir.

- **IBM PROFESSIONAL SKILLS 3 (KİŞİLER ARASI BECERİLER)**
    - **KONU 1: İLETİŞİM TARZLARI**
        - Çoğu insan kişilik özelliklerine ve nasıl iletişim kurmak istediğine göre 4 genel iletişim tarzından birine sahiptir. Doğru veya yanlış bir tarz yoktur. Her tarzın güçlü ve zayıf olduğu noktalar vardır ve hiçbiri diğerinden daha iyi değildir.
            1. **Analizci**: Mantıklı ve gerçeklere dayalı argümanlar arar. Verilerle iletişim kurma eğilimindedir. Sorular sorar ve sistemli kararlar almak için ayrıntılı bilgi arar.
            2. **Yönetici**: Karar veren olma eğilimindedir ve harekete geçer. Kararlı, güçlü fikirlerle işleri kendi yöntemiyle çözmek için sorumluluk almayı sever. Rekabet içinde olmaktan ve riskli durumlardan hoşlanır.
            3. **İlgili**: Önce dinleme daha sonra başkalarıyla bağlantı kurma eğilimindedir. İyi bir dinleyicidir, grup içinde uyumu önemser, istikrar ve kabul görmeye değer verir. Genel başarı ölçüsünün bir parçası olarak arkadaşlarıyla ilişkilerini son derece önemser.
            4. **Dışavurumcu**: Duygularına göre hareket eder. Heyecanını kolayca ifade eder ve yaptığı şeyden keyif almak ve başkalarının da keyif almasını sağlamak onun için çok önemlidir. Konuşkandır, beyin fırtınası yapmayı sever ve sıklıkla başkalarının da katılımını ister. Yeni mücadeleleri ve yeni fikirler denemeyi sever
    
    - **KONU 2: İLETIŞIMDE DAHA BAŞARILI OLMA**
        - Etkili bir iletişimci olmak, her iletişim tarzı için doğru yaklaşımı bulmaktan daha fazlasını gerektirir. Yazarken veya konuşurken başkalarının anlamasını istediğiniz şeyi tam olarak ifade ettiğinizden emin olmanız gerekir. Hedef her zaman daha iyi bir iletişimci olmak olmalıdır.
        - Etkili iletişimin üç öğesi:
            1. Kullandığınız sözcükler
            2. İletişimde kullandığınız vurgu ve tonlama
            3. Beden diliniz
        - Aktif dinleme sırasında şunları göz önünde bulundurmak gerekir:
            1. Tüm dikkati konuşmacıya vermek.
            2. Sözlü olmayan mesajlara dikkat edilmeli.
            3. Mesajın bütününe odaklanmak.
            4. Empati kurma.
            5. Sorular sormak.
        - Mesajınız için doğru iletişim kanalının seçilmesi çok önemlidir. Bu iletişim kanalları sözlü, yüz yüzde ve yazılı yöntemler olabilir.
        - Etkili iletişim için aşılması gereken engellerden bazıları şunlardır:
            1. İletene odaklanma.
            2. Aşırı bilgi yükü.
            3. Dikkat dağıtıcı dış faktörler.
            4. Duygusal tepkiler.
            5. Kişisel gündemlere odaklanma.
    
    - **KONU 3: GİRİŞKEN BİR ŞEKİLDE DAVRANMA**
        - Girişkenlik, başkalarının haklarına saygı duyan açık bir şekilde haklarınızı, düşüncelerinizi, duygularınızı, inançlarınızı ve görüşlerinizi ifade edebilmektir.
        - Girişkenlik, iş yerindeki başarınız için önemlidir.
        - Girişkenlik, çalışma arkadaşlarınızı olumlu yönde etkilemenize ve zorlu durumları yönetebilmenize yardımcı olur.
        - Konuşma şekliniz ve beden diliniz girişken bir şekilde davranabilme becerinizi etkileyebilir.
        - Girişkenlik, iş yerinde görülen aşağıdakiler gibi diğer yaygın davranışlardan farklıdır:
            - Agresif davranış: Agresif insanlar haksız olamayacaklarını düşünme eğilimindedirler ve başkalarının fikirlerine çok açık değildirler.
            - Pasif-agresif davranış: Agresifliğin gizli ve sinsi bir türüdür. Pasif agresif davranışlı insanlar duygularını gizler, ancak gizli gizli işler çevirip tuzaklar kurarak onları kızdıran insanları cezalandırırlar.
            - Pasif davranış: Düşük özgüven göstergesidir. Bu kişiler aklından geçenleri söylemez ve kendilerini neredeyse hiç savunmazlar. Neredeyse hiç "Hayır" demezler ve grup tartışmalarına katılmazlar.
    
    - **KONU 4: ETKİYİ ARTIRMA**
        - Etki, bir kişi veya grubun davranışı, düşünceleri veya duygularını etkileyebilme yeteneğidir. Etkiniz ne kadar güçlü olursa olsun, etrafınızdakiler üzerindeki tesiriniz o kadar fazla olur. Farkında dahi olmadan insanları etkiliyor olabilirsiniz.
        - Kişisel etki ve saygınlık iki önemli etki türüdür.
        - Kişisel etki şu şekilde geliştirilir: Gerçekleri ve duyguları kullanarak, övgüleri başkalarıyla paylaşarak, liderlik görevlerini kabul ederek, görev ve atamalar için gönüllü olarak…
        - Bulunduğunuz iş ortamında saygınlık kazanmak için kullanılan stratejiler: uzmanlık alanınızdaki son gelişmeleri takip etmek, ekibinizin içinde veya dışındaki diğer kişilere yardım etmek, görüşlerinizi kendinizden emin bir şekilde ifade etmek, önerilere ve görüşlere açık olmakla beraber başkalarından da bir şeyler öğrenmek, argümanlarınızı mantık çerçevesinde desteklemek…
        - Kişisel etki ve saygınlığı kullanarak çalışma arkadaşlarınızı olumlu yönde etkilemenin yanı sıra mesleki açıdan da gelişme kaydetmek mümkün.
    
    - **KONU 5: İŞ YERİNDE ANLAŞMAZLIKLARA YAKLAŞIM VE ÇÖZME**
        - İş yerinde sıklıkla zorlu durumlar yaşanır. Bunlar başkalarının davranışlarını ılımlaştırmaya yardımcı olmanız gereken veya siz ve çalışma arkadaşlarınız arasındaki anlaşmazlıkların çözülmesinin zor olduğu durumlar olabilir.
        - Anlaşmazlıklar iki taraflıdır. Zorlu durumlara açıklıkla yaklaşmalısınız.
        - Anlaşmazlıkta şunları belirleyin: ne, kim ve ne zaman.
        - Anlaşmazlık durumlarında bu davranışlardan kaçınmak gerekir: genelleme yapma, yargıya varma ve duygu odaklı ifadeler kullanma.
        - Geribildirim, kişiler arasında yaşanan zorlu durumlarla mücadelede son derece etkili bir mekanizmadır. Geribildirim alırken ve verirken beceri ve dikkat gereklidir.
        - Geribildirim vermenin altı adımı şunlardır:
            1. Geribildirim sağlamak için izin isteyin.
            2. Davranışı ve sonucunu tespit edin.
            3. Alıcının yanıtlaması için duraklayın.
            4. Görmek istediğiniz değişimi dile getirin.
            5. Önerinin nedenini açıklayın.
            6. Alıcının geribildirimi anladığından emin olun.
        - Geribildirim almanın adımları şunları içerir:
            1. Sözü kesmeden veya davranışınızı savunmaya geçmeden geribildirimi dinleyin.
            2. Gerekli açıklamaları isteyin.
            3. Geribildirimin mesajı üzerine derinlemesine düşünün.
            4. Size geribildirim veren kişiye teşekkür edin.
            5. Geribildirim doğrultusunda harekete geçin.
            6. Geribildirimi veren kişiyle süreci takip edin.

---

## 4. Hafta

- **GENEL KÜLTÜR**
    - Kaynak kod, yazılımın orijinal halidir ve yazılım geliştiricileri tarafından yazılır. Bu kod, makine diline çevrilerek çalıştırılabilir hale getirilir. Derleme işlemi, kaynak kodun doğrudan makine koduna dönüştürülmesini sağlar ve bu derleyici tarafından gerçekleştirilir. Makine kodu, bilgisayar tarafından doğrudan çalıştırılabilir. Yorumlama işlemi ise kaynak kodun satır satır okunarak çalıştırılmasıdır ve yorumlayıcı tarafından yapılır. Yorumlama sonucunda çıkan sonuçlar, kullanıcı tarafından görülebilir.
    
    - Derleme ve yorumlama arasında farklar vardır:
        - Derleme, kaynak kodunu makine koduna dönüştürürken, yorumlama satır satır çalıştırır.
        - Derlenen program doğrudan çalıştırılabilirken, yorumlanan program yorumlayıcıya ihtiyaç duyar.
        - Derlenen programlar farklı platformlarda çalışmazken, yorumlanan programlar yorumlayıcı olduğu sürece farklı platformlarda çalışabilir.
        - Derlenen programlar farklı platformlarda çalışmazken, yorumlanan programlar yorumlayıcı olduğu sürece farklı platformlarda çalışabilir.
    
    - C, C++, Java, C# ve Go derlenen dillere örnektir. Python, JavaScript, Ruby, PHP ve Perl ise yorumlanan dillere örnektir. Bir dilin derlenmesi veya yorumlanması, dilin tasarımına ve amacına bağlıdır. Hangi yöntemin seçileceği, projenin gereksinimlerine göre değişir.

- **IBM EXPLORE EMERGING TECH 2 (VERİ BİLİMİ, BLOK ZİNCİR, NESNELERİN İNTERNETİ)**
    - **VERİ BİLİMİ (DATA SCIENCE) NEDİR?**
        - Veri bilimi, verileri toplama, temizleme, analiz etme, yorumlama ve anlamlı bilgiye dönüştürme sürecini içeren disiplinler arası bir alandır. Matematik, istatistik, bilgisayar bilimi ve alan uzmanlığı bilgilerini bir araya getirerek büyük ve karmaşık veri kümelerinden değerli içgörüler elde etmeyi amaçlar. Bu süreç, veri toplama, temizleme, analiz, görselleştirme ve modelleme adımlarını içerir.
        
        - Veri bilimciler, Python, R, SQL, MATLAB, gibi dilleri ve Apache Spark gibi büyük veri teknolojileri ile bulut bilişim platformlarını kullanarak çalışırlar. Birçok endüstride önemli olan veri bilimi, finans, sağlık, perakende ve pazarlama gibi alanlarda stratejik kararlar almak için kullanılır ve organizasyonlara rekabet avantajı sağlar.
    
    - **BLOKZİNCİR (BLOCKCHAIN) NEDİR?**
        - Blokzincir (blockchain), verilerin güvenli, şeffaf ve değiştirilemez şekilde kaydedilmesini sağlayan dağıtık bir dijital defter teknolojisidir. Kriptografik olarak birbirine bağlı veri bloklarından oluşan blokzincir, merkezi bir otoriteye ihtiyaç duymadan ağdaki tüm katılımcılar tarafından yönetilir. Her düğüm, blokzincirin bir kopyasını tutar ve işlemler kriptografi ile korunarak şeffaflık ve izlenebilirlik sağlar.
        
        - Bir kez blokzincire eklenen veriler değiştirilemez, bu da veri bütünlüğünü garanti eder. Blokzincir en çok kripto para birimleriyle bilinse de, finans, tedarik zinciri yönetimi, sağlık ve oylama sistemleri gibi birçok alanda güvenli ve verimli işlemler için kullanılabilir.
        
        - Blockchain’in çalışma prensibi şu şekildedir:
            1. **İşlem Yapma**: Bir kullanıcı ağda bir işlem başlatır, örneğin bir kripto para transferi.
            2. **Blok Oluşturma**: Bu işlem, diğer işlemlerle birlikte bir bloğa dahil edilir.
            3. **Blok Doğrulama**: Blok, ağdaki düğümler (bilgisayarlar) tarafından doğrulanır. Bu, işlemin geçerli olduğundan emin olmak için yapılır.
            4. **Blok Eklenmesi**: Doğrulanan blok, zincirin sonuna eklenir. Bu işlem, kriptografik hash fonksiyonları kullanılarak yapılır, bu da blokların güvenliğini sağlar.
            5. **Zincirin Güncellenmesi**: Zincirin kopyası, ağdaki tüm düğümler tarafından güncellenir, böylece herkes aynı bilgilere sahip olur.
        
        - Blokzincir ve geleneksel veritabanları, yapı ve işlevsellik açısından farklıdır. Blokzincir, verileri birbirine bağlı bloklarda tutan dağıtık ve merkeziyetsiz bir sistemdir; bu sayede veriler değiştirilemez ve yüksek şeffaflık sağlanır, ancak performansı daha yavaş olabilir. Geleneksel veritabanları ise verileri tablolarda saklayan, merkezi otorite tarafından yönetilen sistemlerdir; bu sistemler veri güncellemelerine izin verir, yüksek performans sunar ve güvenlik merkezi kontrolle sağlanır. Blokzincir, kripto paralar ve tedarik zinciri yönetimi gibi alanlarda kullanılırken, geleneksel veritabanları finans, sağlık ve e-ticaret gibi birçok sektörde yaygındır.
        
        - Blockchain'lerin çeşitli sektörlerdeki kullanım senaryosu şöyledir:
            - **Ulaşım**: Bir taşımacılık şirketi, sevkiyatı yapılan malların çıkış birimine kadar hareketini anında izlemek için blockchain tabanlı bir tedarik zinciri yaratabilir. **Örnek:**  [**Digitizing global trade with Maersk and IBM**](https://www.ibm.com/blogs/blockchain/2018/01/digitizing-global-trade-maersk-ibm/)
            - **Kamu:** Devlet yönetimleri, her yıl başa çıkmak zorunda oldukları tahsilatlar, tediyeler, transferler, ücretler, para cezaları, onaylar gibi işlem ve varlıklar yığınını yönetmeye ve dijitalleştirmeye yardımcı olması için blockchain'i kullanabilirler. **Örnek: [How the UAE is empowering its citizens through blockchain](https://www.ibm.com/blogs/blockchain/2018/10/how-the-uae-is-empowering-its-citizens-through-blockchain/)** (IBM Blockchain Blog)
            - **Gıda Zinciri:** Bir gıda şirketi, yiyecekleri kaynağına kadar hızla izlemek için blockchain'i kullanabilir ve gıda kaynaklı hastalık tehdidini azaltabilir. **Örnek: [Blockchain in food safety](https://www.ibm.com/blogs/blockchain/category/blockchain-in-food-safety/)** (IBM Blockchain Blog)
            - **Bankacılık:** Bir banka, ülkeler arası bankacılık işlemleri için gerekli zamanı azaltmak ve ödemeleri gerçek zamanlı olarak doğrulamak için blockchain'i kullanabilir. **Örnek:** [**Practical examples of how blockchains are used in banking and the financial services sector**](https://www.forbes.com/sites/bernardmarr/2017/08/10/practical-examples-of-how-blockchains-are-used-in-banking-and-the-financial-services-sector/#4e5bfeff1a11) (Forbes)
            - **Sağlık Bilimi:** Bir ilaç şirketi, tedarik zincirine giren ve hastaları etkileyen sahte ilaçların akışını durdurmak için blockchain'i kullanabilir. **Örnek:** [**What are the use cases for blockchain tech in healthcare?**](https://www.ibm.com/blogs/blockchain/2018/12/what-are-the-use-cases-for-blockchain-tech-in-healthcare/) (IBM Blockchain Blog)
    
    - **NESNELERİN İNTERNETİ NEDİR? (IOT)**
        - Nesnelerin İnterneti (IoT) terimindeki "nesneler" sözcüğü, bilgileri toplayan, depolayan ve analiz eden sensörlerin yerleştirilmiş olduğu makineler veya aygıtları ifade eder. Bu nesneler internet'e ve merkezi bir veri sunucusuna bağlandığında, daha ayrıntılı işlenmek üzere bu verileri karşıya yükleyebilir ve gerçekleştirilecek birçok görevi kolaylaştırmak için bunlardan yararlanabilir.
 
          ![IBM EXPLORE EMERGING TECH 1 GÖRSEL 4](https://github.com/burakarslan0110/IBM-Kodluyoruz-CyberStart/assets/140614856/9d1a538d-1d2c-4112-8a87-d8c7901ad6d4)
  
        - Bir nesne internet'e bağlandığında, bilgileri gönderebileceği veya alabileceği (veya her ikisi birden) anlamına gelir. Bu bilgi alıp verebilme yeteneği nesneleri "akıllı" yapar. Yani bir nesnenin süper depolaması veya içinde süper bilgisayarı olmasına gerek yoktur; süper depolamaya veya bir süper bilgisayara bağlanabilmesi yeterlidir.
        
        - IoT, daha iyi çalışmasını sağlamak üzere nesnelerin birbiriyle bağlantı kurmasını sağlayarak hayatımızı daha üretken, bağlantılı ve güvenli hale getirir. Çeşitli sektörlerden şu örnekler bu avantajı gözler önüne sermektedir:
            - **Enerji Sektörü**: Sensörler aydınlatma, sıcaklık, enerji kullanımı gibi şeyleri izler. Bu sensör verilerinin işlenmesiyle akıllı algoritmalar, enerji kullanımını insanların yapabildiğinden çok daha etkili bir şekilde yöneterek maliyet ve enerji tasarrufu sağlayabilir.
            - **Olağanüstü Durum Uyarısı:** Çevre hakkında çok önemli bilgileri toplayan sensörler sayesinde, deprem ve tsunami gibi doğal afetleri önceden (bu tür durumlarda saniyeler bile önemlidir)  tespit edilebilir ve böylece insan hayatları kurtarılabilir.
            - **Tarım Endüstrisi:** Toprağın nemini izleyen ve hava durumunu hesaba katan sensörler sayesinde akıllı sulama sistemleri, ekinleri yalnızca gerektiğinde sular, böylece kullanılan su miktarı azalır.

- **IBM PROFESSIONAL SKILLS 4 (ELEŞTİREL VE YARATICI DÜŞÜNMEYLE SORUNLARI ÇÖZME)**
    - Pek çok insanın her gün işte yaptığı şeylerin merkezinde sorunlar vardır, bu nedenle sorunların çözmenin daha iyi yollarını öğrenmek iş performansınızı olumlu yönde etkileyebilir.
    
    - Endişe Çemberi, bazılarını etkileyebileceğiniz, bazılarını etkileyemeyeceğiniz tüm sorunlarınızı içerir.
    
    - Etki Çemberi, endişe çemberiniz içine düşen daha küçük bir etki çemberidir. Etkileyebileceğiniz, kontrol edebileceğiniz ve çözebileceğiniz tüm soruları içerir. Etkinliği yüksek insanlar enerjilerini etki çemberine odaklarlar.
    
    - Sorun çözme süreci 5 adımdan oluşmaktadır.
        1. Belirleme: Sorun nedir?
            - Sorun çözme sürecinin ilk adımı sorunu mümkün olduğunca kısa ve öz tanımlamaktır. Kim, ne zaman, nerede ve ne sorularını yanıtlayarak durumu daha iyi anlarsınız.
        2. Analiz etme: Gerçekten neler oluyor?
            - **Beş Neden**, hemen her soruna uygulayabileceğiniz basit bir tekniktir. Kendinize sorunun neden çıktığını sorun. İlk "neden" sorusunun yanıtını bir diğerini tetikleyecektir. Sorunun kaynağına ulaşıncaya kadar "neden" sorusunu sormaya devam edin.
            - Sorunun temelinde yatan nedeni öğrendiğinizde nasıl ele alacağınıza karar verebilirsiniz. Sorunu çözebilmeniz için bu netlik önemlidir.
        3. Araştırma: Seçenekler neler?
            - Bu adımda sorunun çözümü için birkaç fikir geliştirirsiniz. Sorunların çözülmesi için insanların sıkça yaptığı bir yanlış da tek bir yaklaşıma odaklanmaktır.
            - **Beyin fırtınası** sorunun çözülmesi için birden çok seçeneği araştırmanızı sağlamanın mükemmel bir yolu. Beyin fırtınasının iki önemli kuralı var: Kaliteye değil, miktara bakın ve diğer insanların fikirlerini geliştirin ve iyileştirin.
        4. Seçme: En iyi çözüm nedir?
            - Doğru çözümü seçmek için çözümün maliyeti ve etkinliği dahil kendinizi birkaç faktörün ağırlığını ölçerken bulacaksınız. En iyi çözümü seçerken sorulacak en önemli kilit sorular şunlardır: Çözümü uygulamak ne kadar sürecek, işin çoğunu kim yapacak, liderlik veya yönetim ekibi gibi başka birinden onay alınacak mı ve ölçeklenebilir ve sürdürülebilir mi.
        5. Uygulama: Başarıya ulaşmak nasıl olacak?
            - Sorun çözme sürecinin beşinci yani **Uygulama** adımı 2 bölümden oluşur: İlk bölümde **bir çözümün etkinliğini ölçme yöntemi tasarlarsınız**. Çözümün ölçülmesi, çevik prensipleri olan tekrarlamayı ve rotayı düzeltmeyi de dahil etmenin etkili bir yoludur. Çözüm beklendiği gibi işe yaramıyorsa yararını görene kadar tekrarlayın veya bir sonraki en iyi çözümü seçmek üzere rotanızı değiştirin.
            - İkinci bölümde **çözümünüzü uygulamak için bir plan oluşturursunuz**. Uygulama sürecine ölçme planınızı dahil ettiğinizden emin olun.

- **VERİ YAPILARI VE ALGORİTMALAR**
    - **VERİ YAPILARI**
        1. **Arrays (Diziler)**
            - **Tanım:** Dizi, aynı türden sabit sayıda elemanı tutabilen veri yapısıdır.
            - **Özellikler:** Elemanlar ardışık bellek konumlarında saklanır. Belirli bir index ile elemanlara hızlı erişim sağlanır (O(1)). Dizinin boyutu sabittir ve önceden tanımlanmalıdır.
            - **Kullanım Alanları:** Sıralı veri saklamada, matris işlemlerinde, görüntü işlemede (piksel dizileri)
            - **Avantajları**: Hızlı erişim (sabit zamanlı), Bellek verimliliği, Basit implementasyon.
            - **Dezavantajları**: Dizi boyutu önceden belirlenmekle beraber dinamik olarak değiştirilemez, basit ve kullanımı kolaydır.
        2. **Linked Lists (Bağlı Listeler)**
            - **Tanım:** Bağlı listeler, her bir öğesinin bir sonraki öğeye işaret ettiği, dinamik olarak büyüyebilen veri yapılarıdır. Her öğe bir veri ve bir gösterici (pointer) içerir.
            - **Özellikler**: Dinamik boyutludur. Ekleme ve silme işlemleri dizilere göre daha kolaydır. Elemanlara erişim için baştan sona doğru tarama gerektirir (O(n)).
            - **Kullanım Alanları**: ,Eklemelerin ve silmelerin sıklıkla yapıldığı yerler, Undo/Redo işlevleri, belleğin verimli kullanılması gereken durumlar.
            - **Avantajları:** Dinamik boyut, etkili ekleme ve silme işlemleri, bellek esnekliği.
            - **Dezavantajları:** Rastgele erişim yavaştır (O(n) zaman karmaşıklığı), ek göstericiler bellekte ek yer kaplar.
        3. **Queue (Kuyruk)**
            - **Tanım**: (FIFO - First In First Out) İlk giren ilk çıkar prensibine göre çalışan bir veri yapısıdır. Kuyruğa ilk eklenen eleman, ilk çıkarılan eleman olur.
            - **Özellikler**: İki temel operasyonla çalışır (**Enqueue =** Kuyruğun sonuna eleman ekleme; **Dequeue =** Kuyruğun başından eleman çıkarma)
            - **Kullanım Alanları**: İşlem sırası (task scheduling), veri akışı (data streaming), kaynak paylaşımı (resource management).
            - **Avantajları**: Veri ekleme ve çıkarma işlemleri düzenlidir (O(1) zaman karmaşıklığı), iş sırasını korur.
            - **Dezavantajları**: Ara elemanlara doğrudan erişim yoktur, sabit boyutlu kuyruklar belleği israf edebilir.
        4. **Stack (Yığın)**
            - **Tanım:** Yığın, (LIFO - Last In First Out) Son Giren İlk Çıkar prensibine göre çalışan bir veri yapısıdır. Elemanlar yalnızca bir uçtan (üstten) eklenir ve çıkarılır.
            - **Özellikler**: Temel işlemler (push yani eleman ekleme, pop yani eleman çıkarma, peek yani en üstteki elemanı görme), yalnızca en üstteki elemana erişim sağlar.
            - **Kullanım Alanları:** Fonksiyon çağrıları, ifade değerlendirme, geri alma mekanizmaları.
            - **Avantajlar**: Basit kullanım, hızlı erişim ve işlem, bellek yönetimi.
            - **Dezavantajlar**: Yalnızca üstten erişim mümkündür, ara elemanlara doğrudan erişim yoktur.
        5. **Trees (Ağaçlar)**
            - **Tanım:** Ağaçlar, kök (root) düğümü ile başlayan ve dallara ayrılan, her düğümün alt düğümleri (çocukları) olan hiyerarşik veri yapılarıdır.
            - **Özellikler**: Her düğüm bir veri ve çocuk düğümlere bağlantı içerir, dallanma faktörü ile ağaç genişliği ve derinliği belirlenir.
            - **Kullanım Alanları: V**eri tabanları, dosya sistemleri, hiyerarşik verilerin modellenmesi, sıralama ve arama işlemleri.
            - **Avantajlar**: Veriyi hiyerarşik olarak düzenler; verimli arama, ekleme ve silme işlemleri sağlar.
            - **Dezavantajlar**: Dengeli değilse, performans düşebilir.
        6. **Hash Tables (Hash Tablolar)**
            - **Tanım:** Hash tablolar, anahtar-değer çiftlerini saklayan ve bir anahtarı kullanarak değere hızlıca erişim sağlayan veri yapılarıdır. Hash fonksiyonları kullanarak anahtarları tabloya eşlerler.
            - **Özellikler**: sabit zamanlı erişim (ortalama durumda O(1) zaman karmaşıklığı ile arama, ekleme ve silme işlemleri), dinamik yeniden boyutlandırma.
            - **Kullanım Alanları:** Veritabanı indeksleme, önbellek mekanizmaları, benzersiz veri kümeleri.
            - **Avantajlar**: Hızlı veri arama ve erişimi ve büyük veri kümelerinde etkili.
            - **Dezavantajlar**: Hash çakışmaları (collision) yönetilmelidir ve bellek israfına yol açabilir.
        7. **Graphs (Grafikler)**
            - **Tanım:** Grafikler, düğümler (nodes veya vertices) ve bu düğümler arasındaki bağlantılardan (edges) oluşan veri yapılarıdır. Düğümler ve bağlantılar, çeşitli ilişkileri temsil eder.
            - **Özellikler**: Yönlü-yönsüz, ağırlıklı-ağırlıksız.
            - **Kullanım Alanları:** Ağ analizi, yol bulma algoritmaları, sosyal ağlar.
            - **Avantajlar**: Karmaşık ilişkileri ve bağlantıları temsil eder, esnek ve güçlüdür.
            - **Dezavantajlar**: Karmaşık yapıların yönetimi zordur, bellek ve işlem maliyetleri yüksek olabilir.
    
    - **ALGORİTMALAR**
        - **SORTING ALGORITHMS (SIRALAMA ALGORİTMALARI)**
            - **BUBBLE SORT (KABARCIK SIRALAMASI)**
                - En basit sıralama algoritmalarından biridir. Her adımda komşu elemanları karşılaştırır ve gerekirse yer değiştirir. Bu işlem, dizinin sonuna kadar tekrarlanır ve büyük öğeler "yukarıya doğru" çıkar.
                    - Örnek dizi ve adımlar: `[5, 1, 4, 2, 8]`
                        1. `[1, 5, 4, 2, 8]` (5 ve 1 yer değiştirdi)
                        2. `[1, 4, 5, 2, 8]` (5 ve 4 yer değiştirdi)
                        3. `[1, 4, 2, 5, 8]` (5 ve 2 yer değiştirdi)
                        4. `[1, 4, 2, 5, 8]` (8 yerinde kaldı)
            
            - **SELECTION SORT (SEÇME SIRALAMASI)**
                - Seçme sıralama algoritması her adımda dizinin geri kalan kısmındaki en küçük elemanı bulur ve sıralanmamış kısımdaki ilk elemanla yer değiştirir.
                    - Örnek dizi ve adımlar: `[29, 10, 14, 37, 13]`
                        1. En küçük eleman 10, yer değiştir: `[10, 29, 14, 37, 13]`
                        2. En küçük eleman 13, yer değiştir: `[10, 13, 14, 37, 29]`
                        3. En küçük eleman 14, yerinde kalır: `[10, 13, 14, 37, 29]`
                        4. En küçük eleman 29, yer değiştir: `[10, 13, 14, 29, 37]`
            
            - **INSERTION SORT (EKLEME SIRALAMASI)**
                - Dizinin sıralanmamış kısmından bir eleman alır ve onu sıralanmış kısmına uygun bir şekilde yerleştirir.
                    - Örnek dizi ve adımlar: `[12, 11, 13, 5, 6]`
                        1. 11'i 12'nin önüne ekle: `[11, 12, 13, 5, 6]`
                        2. 13 zaten yerinde: `[11, 12, 13, 5, 6]`
                        3. 5'i uygun yere ekle: `[5, 11, 12, 13, 6]`
                        4. 6'yı uygun yere ekle: `[5, 6, 11, 12, 13]`
            
            - **MERGE SORT (BİRLEŞTİRME SIRALAMASI)**
                - Merge Sort, "böl ve yönet" (divide and conquer) stratejisini kullanan etkili bir sıralama algoritmasıdır. Bu algoritma, diziyi sürekli olarak ikiye böler, alt dizileri sıralar ve sonra bu sıralı alt dizileri birleştirir.
                    - Örnek dizi ve adımlar: `[38, 27, 43, 3, 9, 82, 10]`
                        1. Dizi ikiye bölünür: `[38, 27, 43, 3]` ve `[9, 82, 10]`
                        2. Alt diziler yine ikiye bölünür: `[38, 27]`, `[43, 3]`, `[9]`, `[82, 10]`
                        3. Bölme işlemi biter ve sıralama başlar: `[27, 38]`, `[3, 43]`, `[9]`, `[10, 82]`
                        4. Sıralanmış alt diziler birleştirilir: `[27, 38, 3, 43]`, `[9, 10, 82]`
                        5. Son olarak tüm dizi birleştirilir ve sıralanır: `[3, 9, 10, 27, 38, 43, 82]`
            
            - **QUICK SORT (HIZLI SIRALAMA)**
                - Bu algoritma da "böl ve fethet" prensibini kullanır. Bir "pivot" eleman seçilir ve dizinin diğer elemanları bu pivotun etrafında yeniden düzenlenir.
                - Not: Pivot, sıralama işlemi sırasında diğer elemanların konumlarını belirlemek için referans olarak kullanılan bir elemandır. Genellikle ilk Pivot dizinin son elemanı olarak seçilir.
                    - Örnek dizi ve adımlar: `[10, 7, 8, 9, 1, 5]`
                        1. Pivot olarak 10 seçilir: `[7, 8, 9, 1, 5, 10]`
                        2. 10'un solundaki elemanlar: `[7, 8, 9, 1, 5]`
                        3. Pivot olarak 5 seçilir: `[1, 5, 7, 8, 9, 10]`
                        4. Tekrar pivotlar seçilerek sıralama tamamlanır.
        
        - **SEARCHING ALGORITHMS (ARAMA ALGORİTMALARI)**
            - **LINEAR SEARCH (DOĞRUSAL ARAMA)**
                - Linear search (doğrusal arama) bu en basit arama algoritmasıdır. Dizideki her elemanı teker teker kontrol eder ve aranan öğeyi bulduğunda aramayı durdurur.
                    - Örnek dizi ve adımlar: `[34, 78, 19, 25, 42]` Aranan değer: `25`
                        1. 34'e bak: değil.
                        2. 78'e bak: değil.
                        3. 19'a bak: değil.
                        4. 25'e bak: Evet, bulundu.
            
            - **BINARY SEARCH (İKİLİ ARAMA)**
                - Bu algoritma sıralanmış dizilerde kullanılır. Ortadaki elemanı kontrol eder ve aranan değerin bu elemandan büyük veya küçük olmasına göre aramayı dizinin yarısında devam ettirir.
                    - Örnek sıralı dizi ve adımlar: `[1, 3, 5, 7, 9, 11, 13, 15, 17]` Aranan değer: `7`
                        1. Ortadaki eleman `9`: `7` daha küçük, sol yarıya geç.
                        2. Sol yarı: `[1, 3, 5, 7]`
                        3. Sol yarının ortasındaki eleman `5`: `7` daha büyük, sağ yarıya geç.
                        4. Sağ yarı: `[7]`
                        5. 7 bulundu.
            
            - **FIBONACCI SEARCH (FİBONACCİ ARAMA)**
                - Fibonacci Search (Fibonacci Araması), sıralı bir dizide eleman aramak için kullanılan bir arama algoritmasıdır. Bu algoritma, Fibonacci sayılarını kullanarak arama aralığını daraltma prensibine dayanır. Binary Search'e benzer, ancak bölme noktalarını belirlemek için Fibonacci sayılarını kullanır.
                - Fibonacci Search'ün çalışma prensibi:
                    1. Dizinin uzunluğundan büyük veya eşit en küçük Fibonacci sayısını bul.
                    2. Diziyi iki parçaya böl, bölme noktası bu Fibonacci sayısının bir önceki Fibonacci sayısı kadar geridedir.
                    3. Aranan eleman bölme noktasındaki elemandan küçükse, arama aralığını sol tarafa kaydır.
                    4. Aranan eleman bölme noktasındaki elemandan büyükse, arama aralığını sağ tarafa kaydır.
                    5. Bu işlemi, eleman bulunana veya arama aralığı tükenene kadar tekrarla.
                - Örnek sıralı dizi ve adımlar: `[1, 4, 6, 8, 9, 11, 15, 18, 21]` Aranan değer: `11`
                    1. Dizinin uzunluğu 9. 9'dan büyük en küçük Fibonacci sayısı 13 (Fibonacci serisi: 1, 1, 2, 3, 5, 8, 13, ...)
                    2. Bölme noktası: 13 - 8 = 5 (8, bir önceki Fibonacci sayısından geliyor)
                    3. İlk karşılaştırma: 11 == 11 (5. indeks)
                    4. Eleman bulundu!
        
        - **GREEDY ALGORITHMS (AÇGÖZLÜ ALGORİTMALAR)**
            - Greedy Algoritmalar, optimizasyon problemlerini çözmek için kullanılan bir algoritma tasarım tekniğidir. Bu algoritmaların temel prensibi, her adımda mevcut durumda en iyi görünen seçeneği seçmektir.
            
            - Greedy Algoritmaların Çalışma Prensibi:
                1. Problemi alt problemlere böl.
                2. Her alt problem için en iyi çözümü seç.
                3. Bu seçimleri birleştirerek genel çözümü oluştur.
            
            - Örnek: Para Üstü Problemi
                
                ```python
                Diyelim ki bir kasiyersiniz ve müşteriye 63 TL para üstü vermeniz gerekiyor. 
                Elinizde 50 TL, 20 TL, 10 TL, 5 TL ve 1 TL'lik banknotlar var. Greedy yaklaşımı kullanarak, en az sayıda banknot ile para üstü vermeye çalışacaksınız.
                
                Çözüm:
                
                50 TL ver (Kalan: 13 TL)
                10 TL ver (Kalan: 3 TL)
                1 TL ver (Kalan: 2 TL)
                1 TL ver (Kalan: 1 TL)
                1 TL ver (Kalan: 0 TL)
                
                Toplam 5 banknot kullanıldı: 1 x 50 TL, 1 x 10 TL, 3 x 1 TL
                ```
                
            - Python'da bu problemin çözümü:
                
                ```python
                def para_ustu(tutar, banknotlar):
                    banknotlar.sort(reverse=True)  # Banknotları büyükten küçüğe sırala
                    sonuc = {}
                    for banknot in banknotlar:
                        if tutar >= banknot:
                            adet = tutar // banknot
                            sonuc[banknot] = adet
                            tutar -= adet * banknot
                    return sonuc
                
                # Örnek kullanım
                tutar = 63
                banknotlar = [50, 20, 10, 5, 1]
                sonuc = para_ustu(tutar, banknotlar)
                print(sonuc)  # Çıktı: {50: 1, 10: 1, 1: 3}
                ```
                
        
        - **ALGORİTMA ANALİZİ**
            - Algoritma analizi, bir algoritmanın performansını ve verimliliğini değerlendirmek için yapılan bir çalışmadır. Şu amaçlarla yapılır:
                1. Performans ölçümü: Algoritmanın çalışma süresi ve bellek kullanımı gibi faktörleri değerlendirir.
                2. Karşılaştırma: Farklı algoritmaların aynı problem için etkinliğini karşılaştırmaya olanak sağlar.
                3. Ölçeklenebilirlik: Algoritmanın büyük veri setleriyle nasıl başa çıkacağını tahmin etmeye yardımcı olur.
                4. Optimizasyon: Algoritmanın iyileştirilebilecek alanlarını belirlemeye yardımcı olur.
                5. Kaynak yönetimi: Donanım kaynaklarının etkin kullanımını planlamaya yardımcı olur.
                6. Maliyet tahmini: Algoritmanın gerçek dünya uygulamalarındaki maliyetini öngörmeye yardımcı olur.
            - Bu analiz, genellikle büyük O notasyonu kullanılarak algoritmanın zaman ve alan karmaşıklığını ifade eder.
        
        - **BÜYÜK O NOTASYONU (BIG O NOTATION)**
            - Büyük O notasyonu (Big O notation), algoritmaların zaman ve alan karmaşıklığını ifade etmek için kullanılan bir matematiksel gösterimdir. Bu notasyon, algoritmanın performansının üst sınırını gösterir. Büyük O notasyonu hakkında önemli noktalar:
                1. Tanım: Bir f(n) fonksiyonu için O(g(n)), f(n)'in büyüme hızının en fazla g(n) kadar olduğunu ifade eder.
                2. Asimptotik davranış: Büyük O, girdinin boyutu sonsuza yaklaşırken algoritmanın davranışını tanımlar.
                3. En kötü durum analizi: Genellikle algoritmanın en kötü durum performansını gösterir.
                4. Katsayıları ve düşük dereceli terimleri ihmal eder: Örneğin, 2n² + 3n + 1 ifadesi O(n²) olarak gösterilir.
            
            - Yaygın kullanım alanları:
                - Algoritmaların karşılaştırılması
                - Algoritma verimliliğinin tahmin edilmesi
                - Algoritma tasarımı ve optimizasyonu
            
            - Örnekler:
                - O(1): Sabit zaman (dizinin ilk elemanına erişmek)
                - O(log n): Logaritmik (ikili arama)
                - O(n): Doğrusal (doğrusal arama)
                - O(n log n): Lineer logaritmik (etkili sıralama algoritmaları)
                - O(n²): Karesel (basit sıralama algoritmaları)
            - **Önemli not**: Büyük O, algoritmanın kesin çalışma süresini değil, büyüme oranını gösterir.

- **BİLGİSAYAR AĞLARI**
    - Bilgisayar ağı, iki veya daha fazla bilgisayarın veri paylaşımı ve kaynakları ortak kullanma amacıyla birbirine bağlandığı bir sistemdir. Ağlar, çeşitli donanım ve yazılım bileşenlerinden oluşur ve belirli protokoller aracılığıyla iletişim kurar. Bu, basit bir ev ağından küresel internet ağına kadar geniş bir yelpazeyi kapsar.
    
    - **AĞ TÜRLERİ**
        - Kişisel Alan Ağı (PAN - Personal Area Network)
            - Kişisel cihazlar arasında kurulur. (telefon, tablet, dizüstü).
        - Yerel Alan Ağı (LAN - Local Area Network)
            - Küçük bir coğrafi alanı kapsar (bir ofis, bir bina).
            - Yüksek hızda veri transferi sağlar.
        - Geniş Alan Ağı (WAN - Wide Area Network)
            - Büyük coğrafi alanları kapsar (ülkeler, kıtalar arası).
            - İnternet, en büyük WAN örneğidir.
            - LAN'ların birbirine bağlanmasıyla oluşur.
        - Metropol Alan Ağı (MAN - Metropolitan Area Network):
            - Bir şehir veya metropol alanı kapsar.
            - Üniversite kampüsleri, büyük şirket kampüsleri örnektir.
    
    - **AĞ BİLEŞENLERİ**
        - Ağ Arabirim Kartı (NIC - Network Interface Card)
            - Cihazların ağa bağlanmasını sağlar.
        - Anahtar (Switch)
            - Veri paketlerini doğru hedefe yönlendirir.
            - LAN'larda yaygın olarak kullanılır.
        - Yönlendirici (Router)
            - Ağlar arasında veri yönlendirmesi yapar.
            - İnternete bağlantıyı sağlar.
        - Erişim Noktası (Access Point)
            - Kablosuz ağ bağlantısı sağlar.
        - Modem
            - İnternet servis sağlayıcısından gelen sinyalleri bilgisayarın anlayabileceği hale getirir.
    
    - **AĞ TOPOLOJİLERİ**
        - Yıldız (Star) Topolojisi
            - Tüm cihazlar merkezi bir cihaz (hub/switch) aracılığıyla bağlanır.
            - Merkezi cihaz arızalanırsa tüm ağ etkilenir.
        - Halka (Ring) Topolojisi
            - Cihazlar bir halka şeklinde birbirine bağlanır.
            - Veri belirli bir yönde dolaşır.
            - Bir bağlantı koparsa ağın tamamı etkilenebilir.
        - Veriyolu (Bus) Topolojisi
            - Tüm cihazlar tek bir ana kabloya (bus) bağlanır.
            - Kablonun her iki ucunda sonlandırıcılar bulunur.
            - Kablo koparsa ağda iletişim kesilir.
        - Ağaç (Tree) Topolojisi
            - Yıldız ve veriyolu topolojilerinin birleşimidir.
            - Yüksek güvenilirlik sağlar ancak kurulumu maliyetlidir.
    
    - **AĞ PROTOKOLLERİ**
        - TCP/IP (Transmission Control Protocol/Internet Protocol)
            - İnternetin temel iletişim protokolleridir.
            - Verilerin güvenilir ve sıralı iletimini sağlar.
        - HTTP/HTTPS (Hypertext Transfer Protocol/Secure)
            - Web sayfalarının aktarımı için kullanılır.
            - HTTPS, güvenli şifreleme sağlar.
        - FTP (File Transfer Protocol)
            - Dosya transferi için kullanılır.
        - SMTP (Simple Mail Transfer Protocol)
            - E-posta gönderimi için kullanılır.
        - DNS (Domain Name System)
            - Alan adlarını IP adreslerine çevirir.
        - DHCP (Dynamic Host Configuration Protocol)
            - Bir ağdaki cihazlara otomatik olarak IP adresleri ve diğer ağ yapılandırma bilgilerini atanmak için kullanılan bir ağ yönetim protokolüdür.
        - NAT (Network Address Translation - Ağ Adresi Dönüştürme)
            - NAT, birden fazla ağ cihazının tek bir IP adresi ile internete erişmesine izin veren bir teknolojidir.
    
    - **AĞ GÜVENLİĞİ**
        - Firewall (Güvenlik Duvarı)
            - İzin verilen ve engellenen trafiği denetler.
            - Ağ güvenliği sağlar.
        - Antivirüs Yazılımları
            - Zararlı yazılımları tespit eder ve temizler.
        - VPN (Virtual Private Network):
            - Güvenli ve şifreli bağlantılar sağlar.
            - Özellikle uzaktan çalışanlar için önemlidir.
        - IDS/IPS (Intrusion Detection/Prevention Systems)
            - Ağdaki şüpheli aktiviteleri tespit eder ve önler.
        - Şifreleme
            - Verilerin güvenli iletimi için şifrelenmesi.

- **GENEL KÜLTÜR (AKIŞ DİYAGRAMLARI)**
    - Akış diyagramları (ya da akış şemaları), bir sürecin veya sistemin adımlarını grafiksel olarak gösteren görsel araçlardır. Bu diyagramlar, bir sürecin nasıl çalıştığını, hangi adımların izlendiğini ve bu adımların hangi sırayla gerçekleştirildiğini açıklamak için kullanılır.

      ![Akış-Görsel](https://github.com/burakarslan0110/IBM-Kodluyoruz-CyberStart/assets/140614856/eb6f7bac-0032-4e45-8790-bdc877bac2e2)
    - Akış Diyagramlarının Temel Unsurları:
        1. Başlangıç ve Bitiş (Oval)
            - Sürecin başlangıç ve bitiş noktalarını belirtir.
            - Genellikle "Başla" ve "Bitir" olarak etiketlenir.
        2. Eylem veya İşlem (Dikdörtgen)
            - Süreçte gerçekleştirilen bir adımı veya işlemi temsil eder.
            - Örneğin, "Veri Girişi" veya "Hesaplama Yap" gibi.
        3. Karar (Elmas)
            - Süreçte bir karar noktasını belirtir ve iki veya daha fazla olası yolu gösterir.
            - Örneğin, "Şart Sağlandı mı?" gibi.
        4. Akış Çizgileri (Oklar)
            - Adımlar arasındaki akışı ve sıralamayı gösterir.
            - İşlemden işleme, karardan işleme geçişleri belirtir.
        5. Girdi/Çıktı (Paralelkenar)
            - Süreçteki veri giriş ve çıkışlarını belirtir.
            - Örneğin, "Rapor Al" veya "Veri Oku" gibi.
        6. Bağlantı (Daire)
            - Diyagramın farklı bölümlerini birbirine bağlar, genellikle karmaşık diyagramlarda kullanılır.

---

## 5. Hafta

- **GENEL KÜLTÜR**
    - Kodun okunabilirliği, anlaşılırlığı artıran önemli bir beceridir. Bunun için uygulanabilecek yol ve yöntemler şu şekildedir:
        - Doğru sözdizimi ve girintileme kullanma.
        - Değişkenlere amaçlarına uygun kısa ve açıklayıcı isimler verme.
        - Gerektiği yerde yorum satırı kullanma.
        - Kodu mantıksal bloklara bölme.
        - Okunabilirliği düşük kod yerine temiz kod yazma.

- **IBM CYBERSECURITY FUNDAMENTALS**
    - IBM SkillsBuild platformunda 6 saat süren Siber Güvenliğin Temelleri eğitiminde önemli kavramların tanımlarıyla birlikte yer aldığı notlarım.
        - **Siber Güvenlik (Cybersecurity)**: Bilgi sistemlerini, ağları, programları ve verileri siber saldırılardan koruma süreci.
        - **Ağ Güvenliği (Network Security)**: Bilgisayar ağlarını yetkisiz erişim, kötüye kullanım, arızalar, değişiklikler, tahribat veya açıklamalardan koruma uygulamaları.
        - **Bilgi Güvenliği (Information Security)**: Bilgiyi yetkisiz erişim ve kullanımdan koruma süreci.
        - **Siber Saldırı (Cyber Attack)**: Bilgisayar sistemlerine veya ağlarına zarar vermek, bilgi çalmak veya hizmetleri kesintiye uğratmak amacıyla yapılan kötü niyetli eylemler.
        - **Kötü Amaçlı Yazılım (Malware)**: Bilgisayar sistemlerine zarar vermek, veri çalmak veya kontrolü ele geçirmek için tasarlanmış yazılımlar.
        - **Virüs (Virus)**: Kendini çoğaltarak diğer dosyalara bulaşan ve sisteme zarar veren kötü amaçlı yazılım.
        - **Truva Atı (Trojan Horse)**: Zararsız gibi görünen ancak kötü amaçlı işlevler gerçekleştiren yazılım.
        - **Solucan (Worm)**: Ağlar üzerinden yayılan ve sistem kaynaklarını tüketen kötü amaçlı yazılım.
        - **Fidye Yazılımı (Ransomware)**: Kullanıcıların verilerini şifreleyip, bu verileri geri vermek için fidye talep eden kötü amaçlı yazılım.
        - **Casus Yazılım (Spyware)**: Kullanıcı bilgilerini gizlice toplayan ve üçüncü taraflara ileten yazılım.
        - **Açık (Vulnerability)**: Bir sistemde bulunan ve kötü niyetli kişilerin kullanabileceği güvenlik zafiyeti.
        - **Sıfır Gün Açığı (Zero-Day Vulnerability)**: Güvenlik açıklarının keşfedildiği anda henüz kapatılmamış ve potansiyel olarak saldırıya açık olduğu dönem.
        - **Sosyal Mühendislik (Social Engineering)**: İnsanların güvenlik sistemlerini kandırmak için psikolojik manipülasyon tekniklerini kullanma.
        - **Kimlik Avı (Phishing)**: Kullanıcıları kandırarak kişisel ve finansal bilgilerini çalmayı amaçlayan saldırılar.
        - **DDoS Saldırısı (DDoS Attack)**: Hizmetleri erişilemez hale getirmek amacıyla bir hedefe çok sayıda sahte istek gönderme.
        - **Brute Force Saldırısı (Brute Force Attack)**: Parola veya şifreleri deneme-yanılma yöntemiyle kırmaya çalışan saldırı.
        - **SQL Enjeksiyonu (SQL Injection)**: Veri tabanlarına yetkisiz erişim sağlamak amacıyla kötü niyetli SQL komutları kullanma.
        - **XSS (Cross-Site Scripting)**: Web uygulamalarında kullanıcıların tarayıcılarında zararlı kod çalıştırma saldırısı.
        - **Ortadaki Adam (MitM) Saldırısı: İ**ki taraf arasındaki iletişimi gizlice dinlemek, değiştirmek veya sahte bir şekilde yeniden yönlendirmek amacıyla gerçekleştirilen siber saldırıdır. Bu saldırıda, saldırgan, iletişimi kuran tarafların kimliklerini bilmeden, aralarına girer ve veri alışverişine müdahale eder.
        - **Güvenlik Duvarı (Firewall)**: Ağ trafiğini kontrol eden ve yetkisiz erişimleri engelleyen güvenlik sistemi.
        - **Botnet:** Birçok bilgisayarın (botların) kötü niyetli bir saldırgan tarafından ele geçirilip, merkezi bir kontrol noktasından yönetildiği bir ağdır
        - **Antivirüs Yazılımı (Antivirus Software)**: Kötü amaçlı yazılımları tespit eden ve bunları kaldıran program.
        - **Şifreleme (Encryption)**: Verilerin yetkisiz erişimlere karşı korunması için kodlanması süreci.
        - **SSL/TLS (Secure Sockets Layer/Transport Layer Security)**: İnternet üzerinden güvenli veri iletimini sağlayan protokoller.
        - **VPN (Virtual Private Network)**: Güvensiz ağlar üzerinden güvenli bağlantı kurmayı sağlayan teknoloji.
        - **İki Faktörlü Kimlik Doğrulama (Two-Factor Authentication)**: Kullanıcı kimliğini doğrulamak için iki farklı doğrulama yöntemi kullanma.
        - **IAM (Identity and Access Management)**: Kullanıcı kimliklerini ve erişim haklarını yönetme süreci.
        - **Veri Sızıntısı (Data Breach)**: Hassas, korumalı veya gizli bilgilerin yetkisiz kişilere ifşa edilmesi.
        - **Penetrasyon Testi (Penetration Testing)**: Güvenlik açıklarını tespit etmek için bir sisteme yetkisiz erişim denemeleri yapma.
        - **Siber Tehdit İstihbaratı (Cyber Threat Intelligence)**: Olası siber tehditler hakkında bilgi toplama ve analiz etme süreci.
        - **APT (Advanced Persistent Threat)**: Uzun süreli ve hedefe yönelik siber saldırılar.
        - **İç Tehdit (Insider Threat)**: Bir organizasyon içindeki kişilerin neden olduğu güvenlik tehditleri.
        - **CISO (Chief Information Security Officer)**: Bir organizasyonun bilgi güvenliğinden sorumlu üst düzey yönetici.
        - **SOC (Security Operations Center)**: Güvenlik olaylarını izleyen ve müdahale eden ekip veya birim.
        - **SIEM (Security Information and Event Management)**: Güvenlik olaylarını toplayan, analiz eden ve raporlayan yazılımlar.
        - **BYOD (Bring Your Own Device)**: Çalışanların kendi cihazlarını iş ortamında kullanmalarına izin veren politika.
        - **MFA (Multi-Factor Authentication)**: Kullanıcı doğrulaması için birden fazla doğrulama yöntemi kullanma.
        - **Saldırı Yüzeyi (Attack Surface)**: Bir sistemin saldırıya açık olan tüm noktaları.
        - **İzinsiz Giriş Tespit Sistemi (IDS - Intrusion Detection System)**: Ağ veya sistem üzerindeki izinsiz girişleri tespit eden sistem.
        - **İzinsiz Giriş Önleme Sistemi (IPS - Intrusion Prevention System)**: İzinsiz girişleri engellemek için önlemler alan sistem.
        - **Uç Nokta Güvenliği (Endpoint Security)**: Bilgisayarlar, mobil cihazlar ve diğer uç noktaların korunması.
        - **Güvenlik Açığı Yönetimi (Vulnerability Management)**: Güvenlik açıklarını tespit etme, değerlendirme ve kapatma süreci.
        - **Güvenlik Politikası (Security Policy)**: Bir organizasyonun bilgi güvenliğiyle ilgili kuralları ve prosedürleri.
        - **Kriptografi (Cryptography)**: Verilerin şifrelenmesi ve çözümlenmesi bilimi.
        - **Saldırı Simülasyonu (Red Team/Blue Team)**: Güvenlik açıklarını tespit etmek için yapılan saldırı ve savunma senaryoları.
        - **Kimlik Doğrulama (Authentication)**: Kullanıcının kimliğini doğrulama süreci.
        - **Yetkilendirme (Authorization)**: Kullanıcının belirli kaynaklara erişim izni olup olmadığını belirleme süreci.
        - **Güvenlik Açığı (Exploit)**: Bir güvenlik açığından yararlanma yöntemi veya yazılımı.
        - **Yamalama (Patching)**: Yazılım veya donanım sistemlerindeki güvenlik açıklarını kapatmak için yapılan güncellemeler.
        - **Risk Yönetimi (Risk Management)**: Güvenlik risklerini belirleme, değerlendirme ve azaltma süreci.
        - **Siber Hijyen (Cyber Hygiene)**: Güvenli bilgi teknolojisi kullanımını teşvik eden uygulamalar ve önlemler.
        - **Veri Kaybı Önleme (Data Loss Prevention - DLP)**: Hassas bilgilerin yanlışlıkla veya kötü niyetli olarak dışarıya sızmasını önlemek için alınan önlemler.

- **GENEL KÜLTÜR (FONKSIYONEL VE NESNE TABANLI PROGRAMLAMA)**
    - Fonksiyonel Programlama: Programları matematiksel fonksiyonlara dayalı olarak tasarlayan bir programlama paradigmasıdır. Fonksiyonel programlamanın temel özellikleri ise şu şekilde:
        1. **Saf Fonksiyonlar**: Fonksiyonel programlamada fonksiyonlar saf (pure) olmalıdır. Bu, fonksiyonun aynı girdilere her zaman aynı çıktıyı vermesi ve yan etkilerden bağımsız olması anlamına gelir.
        2. **Yüksek Dereceli Fonksiyonlar**: Fonksiyonel programlamada, fonksiyonlar birinci sınıf varlıklardır, yani fonksiyonlar diğer fonksiyonlara parametre olarak geçebilir veya fonksiyonlar tarafından döndürülebilir.
        3. **Değişmezlik (Immutability)**: Fonksiyonel programlama, değişkenlerin değişmezliğine vurgu yapar. Bir kez atandıktan sonra bir değişkenin değeri değiştirilemez.
        4. **Yan Etkisizlik (Side-effect-free)**: Fonksiyonlar, sistemin durumunu değiştirmez veya dış dünya ile etkileşime girmez. Bu, fonksiyonların tahmin edilebilir ve test edilebilir olmasını sağlar.
        5. **Fonksiyonel Kompozisyon**: Küçük ve bağımsız fonksiyonlar, daha karmaşık fonksiyonlar oluşturmak için birleştirilebilir.
        6. **Laziness (Tembelevaluation)**: Hesaplamalar, ihtiyaç duyulana kadar ertelenir. Bu, performansı optimize etmeye ve sonsuz veri yapılarıyla çalışmaya olanak tanır.
    
    - Nesne Tabanlı Programlama (OOP): Programları nesneler etrafında organize eden bir paradigmadır. OOP'nin temel özellikleri:
        1. **Sınıflar ve Nesneler**: OOP'de, sınıflar (classes) ve nesneler (objects) temel yapı taşlarıdır. Sınıflar, nesnelerin şablonlarıdır ve nesneler, bu şablonlara göre oluşturulan varlıklardır.
        2. **Kapsülleme (Encapsulation)**: Nesnelerin durumunu (veri) ve davranışını (metotlar) bir arada tutar. Veriye erişim ve değişim, sadece belirlenmiş yöntemlerle yapılabilir.
        3. **Kalıtım (Inheritance)**: Bir sınıf, başka bir sınıftan türetilebilir, böylece özelliklerini ve metotlarını miras alır. Bu, kod tekrarını azaltır ve yeniden kullanılabilirliği artırır.
        4. **Polimorfizm (Polymorphism)**: Farklı nesneler, aynı arayüzü kullanarak farklı şekillerde davranabilir. Bu, esnek ve genişletilebilir bir kod yapısı oluşturur.
        5. **Soyutlama (Abstraction)**: Gereksiz ayrıntılardan sakınarak, sadece gerekli olan detayların ön plana çıkarılmasını sağlar. Bu, karmaşıklığı azaltır ve anlaşılabilirliği artırır.
    
    - Her iki paradigma da kendi bağlamlarında güçlüdür ve hangisinin kullanılacağı, projenin gereksinimlerine ve geliştiricinin tercihine bağlıdır. Fonksiyonel programlama, durumun önemli olmadığı veya yan etkilerin minimal olduğu durumlar için genellikle daha uygundur. Nesne tabanlı programlama ise genellikle büyük ve karmaşık yazılım sistemlerinde, nesneler arasındaki etkileşimi modellemek için kullanılır. Modern yazılım geliştirme süreçlerinde, bu iki yaklaşımın kombinasyonları da sıkça kullanılmaktadır.

---

## 6. Hafta

- **GENEL KÜLTÜR**
    - **Kapalı Yazılım (Proprietary Software)**:  Değiştirilmesi ve dağıtılması belirli bir lisans altında sıkı bir şekilde kontrol edilen yazılımdır. Bu tür yazılımlar genellikle ticari şirketler tarafından geliştirilir ve kullanıcılar genellikle bu yazılımların kaynak koduna erişemezler. Kullanıcılar, yazılımı yalnızca belirli şartlar ve kısıtlamalar altında kullanabilirler. Kapalı yazılımların avantajları arasında güvenlik ve destek garantileri bulunur, ancak kullanıcılar yazılımı özelleştiremez veya değiştiremezler.
    
    - **Açık Yazılım (Open Source Software):** Açık yazılım, kaynak kodunun herkese açık olduğu ve herhangi birinin bu kodu inceleyebileceği, değiştirebileceği ve dağıtabileceği yazılımlardır. Bu yazılımlar genellikle bir topluluk tarafından geliştirilir ve kullanıcılar yazılımı kendi ihtiyaçlarına göre özelleştirebilirler. Açık yazılım lisansları, yazılımın serbestçe kullanılmasını ve değiştirilmesini sağlar.
    
    - **Özgür Yazılım (Free Software)**: Özgür yazılım, kullanıcılara yazılımı kullanma, inceleme, değiştirme ve dağıtma özgürlükleri tanıyan bir yazılım kategorisidir. "Free" kelimesi burada maliyetten çok özgürlüğe atıfta bulunur. Özgür yazılım felsefesi, kullanıcıların yazılım üzerinde tam kontrol sahibi olmasını savunur. Bu terim genellikle GNU Genel Kamu Lisansı (GPL) gibi lisanslar altında dağıtılan yazılımlar için kullanılır.
    
    - Özgür yazılım, kullanıcıların ve geliştiricilerin yazılımın her yönünü özgürce kontrol etmelerine izin verir ve genellikle açık yazılım ile örtüşür. Ancak tüm açık yazılımlar özgür yazılım değildir; bir yazılımın özgür olması için belirli özgürlükleri sağlaması gereklidir.

- **TASARIM ODAKLI DÜŞÜNME**
    - Tasarım Odaklı Düşünme (Design Thinking), insan merkezli bir problem çözme yaklaşımıdır. Bu yöntem, tasarımcıların kullandığı düşünce süreçlerini ve araçları kullanarak karmaşık problemleri anlamaya, kullanıcı ihtiyaçlarını keşfetmeye ve yaratıcı çözümler geliştirmeye odaklanır. Temelde, kullanıcıların deneyimlerini ve ihtiyaçlarını merkeze alarak inovatif çözümler üretmeyi hedefler. Tasarım Odaklı Düşünme süreci genellikle beş adımdan oluşur:
        1. **Empati Kurma (Empathize):** Kullanıcıları ve onların ihtiyaçlarını derinlemesine anlamak için empati kurma aşamasıdır. Bu aşamada gözlem, görüşme ve kullanıcı deneyimlerine dair diğer araştırma yöntemleri kullanılır.
        2. **Tanımlama (Define):** Kullanıcıların ihtiyaçlarını ve karşılaştıkları problemleri belirlemek için elde edilen bilgilerin analiz edilmesi aşamasıdır. Bu aşamada, kullanıcı ihtiyaçlarına odaklanarak net ve anlamlı bir problem tanımı yapılır.
        3. **Fikir Üretme (Ideate):** Belirlenen problem için olası çözümler üretme aşamasıdır. Bu aşamada, beyin fırtınası ve diğer yaratıcı düşünme teknikleri kullanılarak mümkün olduğunca çok fikir üretilir.
        4. **Prototip Oluşturma (Prototype):** Üretilen fikirlerin somut hale getirilmesi aşamasıdır. Bu aşamada, hızlı ve düşük maliyetli prototipler geliştirilerek fikirlerin nasıl çalıştığı test edilir.
        5. **Test Etme (Test):** Prototiplerin gerçek kullanıcılarla test edilmesi aşamasıdır. Bu aşamada, kullanıcı geri bildirimleri alınarak prototipler iyileştirilir ve gerekirse süreç yeniden başlatılarak daha iyi çözümler bulunur.
    
    - Tasarım Odaklı Düşünme, sadece ürün tasarımıyla sınırlı kalmayıp, hizmet tasarımı, iş modeli geliştirme ve organizasyonel değişim gibi birçok alanda kullanılabilir. Bu yaklaşımın temel amacı, kullanıcı odaklı ve yaratıcı çözümler geliştirerek, daha etkili ve tatmin edici sonuçlar elde etmektir.

- **GENEL KÜLTÜR (DOKÜMANTASYONUN YAZILIM DÜNYASINDAKİ ÖNEMİ)**
    - Yazılım endüstrisi hızla değişen bir alan ve dokümantasyon, bu dinamik ortamda büyük bir önem taşır. Dokümantasyonun yazılımda neden bu kadar önemli olduğunun temel nedenleri:
        - **Kodun Anlaşılırlığı:** Dokümantasyon, kodun niçin ve nasıl yazıldığını açıklar, böylece yeni gelen yazılımcılar bile sistemi hızla anlayabilir.
        - **Kullanıcı Desteği:** API'ler, kütüphaneler ve ürünler için dokümantasyon, kullanıcıların bu araçları doğru kullanmalarını sağlar ve kullanıcı deneyimini artırır.
        - **Hata Ayıklama:** Yazılım hatalarını tespit etmek ve çözmek için dokümantasyon, hangi fonksiyonların nasıl çalıştığını anlamada yardımcı olur.
        - **İşbirliği ve Takım Çalışması:** Dokümantasyon, ekip üyelerinin aynı bilgi seviyesine ulaşmasını ve projeyi takip etmesini sağlar.
        - **Proje Planlama ve Geliştirme:** Özellikler ve gereksinimlerin dokümantasyonu, projelerin doğru planlanmasına ve yönetilmesine yardımcı olur.
        - **Tarihsel Kayıt:** Dokümantasyon, yazılımın tarihçesini saklar ve geçmişte alınan kararları ve çözülen sorunları anlamada kritiktir.
    
    - Sonuç olarak, dokümantasyon, yazılım projelerinin etkili ve verimli bir şekilde yürütülmesinde ve kodun sürdürülebilirliğinde kilit bir rol oynar. Yazılım projelerinde dokümantasyonun önemini göz ardı etmeyin!
